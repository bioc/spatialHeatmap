% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spd_auc_violin.R
\name{spd_auc_violin}
\alias{spd_auc_violin}
\title{Violin plot of extracted AUCs by top spd.sets}
\usage{
spd_auc_violin(
  df.lis,
  n = 5,
  ylab = "AUC",
  xlab,
  x.agl = 45,
  x.vjust = 0.6,
  nrow = 3,
  title = NULL,
  key.title = NULL,
  lgd.key.size = 0.03
)
}
\arguments{
\item{df.lis}{The nested list of extracted aucs returned by \code{auc_stat}.}

\item{n}{Number of top \code{spd.set} ranked by frequencies to plot.}

\item{xlab, ylab}{The x and y axis labels in the violin plots.}

\item{x.agl, x.vjust}{Angle and vertical position to adjust x-axis text.}

\item{nrow}{The numbers of rows of all the violin plots.}

\item{title}{The title of composite violin plots.}

\item{key.title}{The title of legend.}

\item{lgd.key.size}{The size of legend keys.}
}
\value{
An object of ggplot.
}
\description{
In coclustering optimization, visualize extracted AUCs by top spd.sets ranked by frequency in violin plots.
}
\examples{
# To obtain reproducible results, always start a new R session and set a fixed seed for Random Number Generator at the begaining, which is required only once in each R session.  
set.seed(10)

# Example bulk data of Arabidopsis thaliana (Arabidopsis) root for coclustering optimization (Li et al 2016).
blk <- readRDS(system.file("extdata/cocluster/data", "bulk_cocluster.rds", package="spatialHeatmap"))

# Example single cell data of Arabidopsis thaliana (Arabidopsis) root for coclustering optimization (Shahan et al 2020).
sc10 <- readRDS(system.file("extdata/cocluster/data", "sc10_cocluster.rds", package="spatialHeatmap"))
sc11 <- readRDS(system.file("extdata/cocluster/data", "sc11_cocluster.rds", package="spatialHeatmap"))

\donttest{
# These example data are already pre-processed. To demonstrate the optimization process the pre-processing steps are perfomed again with few genes or cells removed.

# Inital filtering before normalization. 
blk <- filter_data(data=blk, pOA=c(0.2, 15), CV=c(1.5, 100)); dim(blk)

fil.init <- filter_cell(lis=list(sc10=sc10, sc11=sc11), bulk=blk, gen.rm='^ATCG|^ATCG', min.cnt=1, p.in.cell=0.3, p.in.gen=0.1)

# Normalization.
# sum.factor.
norm.fct <- norm_multi(dat.lis=fil.init, cpm=FALSE)
# sum.factor + CPM.
norm.cpm <- norm_multi(dat.lis=fil.init, cpm=TRUE)

# Secondary filtering.
# Filtering parameter sets.
df.par.fil <- data.frame(p=c(0.1, 0.2, 0.3, 0.4), A=rep(1, 4), cv1=c(0.1, 0.2, 0.3, 0.4), cv2=rep(100, 4), min.cnt=rep(1, 4), p.in.cell=c(0.1, 0.25, 0.3, 0.35), p.in.gen=c(0.01, 0.05, 0.1, 0.15))
df.par.fil

# Filtered results are saved in "opt_res".
if (!dir.exists('opt_res')) dir.create('opt_res')
fct.fil.all <- filter_iter(bulk=norm.fct$bulk, cell.lis=list(sc10=norm.fct$sc10, sc11=norm.fct$sc11), df.par.fil=df.par.fil, gen.rm='^ATCG|^ATCG', wk.dir='opt_res', norm.meth='fct')

cpm.fil.all <- filter_iter(bulk=norm.cpm$bulk, cell.lis=list(sc10=norm.cpm$sc10, sc11=norm.cpm$sc11), df.par.fil=df.par.fil, gen.rm='^ATCG|^ATCG', wk.dir='opt_res', norm.meth='cpm')

# Matching table between bulk tissues and single cells.
match.pa <- system.file("extdata/cocluster/data", "match_arab_root_cocluster.txt", package="spatialHeatmap")
df.match.arab <- read.table(match.pa, header=TRUE, row.names=1, sep='\t')
df.match.arab[1:3, ]

# Optimization. 
# Check parallelization guide.
coclus_opt(wk.dir='opt_res', parallel.info=TRUE, dimred=c('PCA', 'UMAP'), graph.meth=c('knn', 'snn'), sim=seq(0.2, 0.4, by=0.1), sim.p=seq(0.2, 0.4, by=0.1), dim=seq(5, 7, by=1))

# The first-level parallel computing relies on the slurm scheduler (https://slurm.schedmd.com/documentation.html), so if it is available the whole optimization process could be parallelized at two levels. 
file.copy(system.file("extdata/cocluster", "slurm.tmpl", package="spatialHeatmap"), './slurm.tmpl')

# The first- and second-level parallelizations are set 3 and 2 respectively.
library(BiocParallel)
opt <- coclus_opt(wk.dir='opt_res', dimred=c('PCA', 'UMAP'), graph.meth=c('knn', 'snn'), sim=seq(0.2, 0.4, by=0.1), sim.p=seq(0.2, 0.4, by=0.1), dim=seq(5, 7, by=1), df.match=df.match.arab, batch.par=BatchtoolsParam(workers=3, cluster="slurm", template='slurm.tmpl'), multi.core.par=MulticoreParam(workers=2))

# If slurm is not available, parallelize the optimization only at the second-level through 2 workers. 
opt <- coclus_opt(wk.dir='opt_res', dimred=c('PCA', 'UMAP'), graph.meth=c('knn', 'snn'), sim=seq(0.2, 0.4, by=0.1), sim.p=seq(0.2, 0.4, by=0.1), dim=seq(5, 7, by=1), df.match=df.match.arab, batch.par=NULL, multi.core.par=MulticoreParam(workers=2))

# The performaces of parameter settings are measured by AUC values in ROC curve. The following demonstrates how to visualize the AUCs and select optimal parameter settings.

# Extract AUCs and other parameter settings for filtering parameter sets.
df.lis.fil <- auc_stat(wk.dir='opt_res', tar.par='filter', total.min=500, true.min=300, aucs=round(seq(0.5, 0.9, 0.1), 1))
df.lis.fil$df.auc.mean[1:3, ]

# Mean AUCs by each filtering settings and AUC cutoff.
mean_auc_bar(df.lis.fil[[1]], bar.width=0.07, title='Mean AUCs by filtering settings')

# All AUCs by each filtering settings and AUC cutoff. 
auc_violin(df.lis=df.lis.fil, xlab='Filtering settings')

# Optimal filtering settings: fil1, fil2, fil3
df.par.fil[c(1, 2, 3), ]

# Extract AUCs and other parameter settings for normalization methods.
df.lis.norm <- auc_stat(wk.dir='opt_res', tar.par='norm', total.min=500, true.min=300, aucs=round(seq(0.5, 0.9, 0.1), 1))
df.lis.norm$df.auc.mean[1:3, ]

# Mean AUCs by each normalization method and AUC cutoff.
mean_auc_bar(df.lis.norm[[1]], bar.width=0.07, title='Mean AUCs by normalization methods')

# All AUCs by each normalization method and AUC cutoff. 
auc_violin(df.lis=df.lis.norm, xlab='Normalization methods')

# Optimal normalization method: fct (computeSumFactors).

# Extract AUCs and other parameter settings for graph-building methods.
df.lis.graph <- auc_stat(wk.dir='opt_res', tar.par='graph', total.min=500, true.min=300, aucs=round(seq(0.5, 0.9, 0.1), 1))
df.lis.graph$df.auc.mean[1:3, ]

# Mean AUCs by each graph-building method and AUC cutoff.
mean_auc_bar(df.lis.graph[[1]], bar.width=0.07, title='Mean AUCs by graph-building methods')

# All AUCs by each graph-building method and AUC cutoff. 
auc_violin(df.lis=df.lis.graph, xlab='Graph-building methods')

# Optimal graph-building methods: knn (buildKNNGraph).

# Extract AUCs and other parameter settings for dimensionality reduction methods.
df.lis.dimred <- auc_stat(wk.dir='opt_res', tar.par='dimred', total.min=500, true.min=300, aucs=round(seq(0.5, 0.9, 0.1), 1))
df.lis.dimred$df.auc.mean[1:3, ]

# Mean AUCs by each dimensionality reduction method and AUC cutoff.
mean_auc_bar(df.lis.dimred[[1]], bar.width=0.07, title='Mean AUCs by dimensionality reduction methods')

# All AUCs by each dimensionality reduction method and AUC cutoff. 
auc_violin(df.lis=df.lis.dimred, xlab='Dimensionality reduction')

# Optimal dimensionality reduction method: pca (denoisePCA).

# Extract AUCs and other parameter settings for spd.sets.
df.lis.spd <- auc_stat(wk.dir='opt_res', tar.par='spd.set', total.min=500, true.min=300, aucs=round(seq(0.5, 0.9, 0.1), 1))
df.lis.spd$auc0.5$df.frq[1:3, ]

# All AUCs of top spd.sets ranked by frequency. 
spd_auc_violin(df.lis=df.lis.spd, n=5, xlab='spd.sets', x.vjust=0.6)
}
}
\references{
H. Wickham. ggplot2: Elegant Graphics for Data Analysis. Springer-Verlag New York, 2016.
Baptiste Auguie (2017). gridExtra: Miscellaneous Functions for "Grid" Graphics. R package version 2.3. https://CRAN.R-project.org/package=gridExtra
}
\author{
Jianhai Zhang \email{jzhan067@ucr.edu} \cr Dr. Thomas Girke \email{thomas.girke@ucr.edu}
}
