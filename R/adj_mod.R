#' Compute Adjacency Matrix and Identify Modules
#'
#' It is designed to compute adjacency matrix and identify modules for the filtered expression matrix. The computation is computationally intensive for large gene expression matrix (e.g. > 10,000 genes). Therefore, when using the web-browser based spatialHeatmap, the large expression matrix should be first computed locally using this function then the resulting files should be uploaded to "Compute locally" in the app.

#' @param data A "SummarizedExperiment" object containing the processed data matrix and metadata returned by the function "filter_data".

#' @param type There are two options in this argument, "signed" and "unsigned". "signed" means both positive and negative adjacency between genes are maintained in network module identification while "unsigned" takes the absolute values of negative adjacency. Refer to "WGCNA" (Langfelder and Horvath 2008) for more details.

#' @param minSize The minimum module size in module identification. The default value is 15. Refer to "WGCNA" for more details.

#' @param dir The path where the directory "local_mode_result/" is created automatically to save resulting files "adj.txt" and "mod.txt". This argument should be the same with that from the function "filter_data" so that the processed data matrix generated by "filter_data" is saved in the same location. The default is NULL.

#' @return A list containing the adjacency matrix and module assignment. If "dir" is not NULL, both are automatically saved in the directory "local_mode_result" as "adj.txt" and "mod.txt" respectively. 

#' @examples
#' # Creat the "SummarizedExperiment" class. Refer to the R package "SummarizedExperiment" for more details.
#' data.path <- system.file("extdata/shinyApp/example", "root_expr_row_gen.txt", package = "spatialHeatmap")   
#' ## The expression matrix, where the row and column names should be gene IDs and sample/conditions respectively. This data matrix is truncated from a GEO dataset (https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE46205), which is already normalised.
#' library(data.table); expr <- fread(data.path, sep='\t', header=TRUE, fill=TRUE)
#' col.na <- colnames(expr)[-ncol(expr)]; row.na <- as.data.frame(expr[, 1])[, 1]
#' expr <- as.matrix(as.data.frame(expr, stringsAsFactors=FALSE)[, -1])
#' rownames(expr) <- row.na; colnames(expr) <- col.na
#' col.met.path <- system.file("extdata/shinyApp/example", "col_metadata.txt", package = "spatialHeatmap") 
#' ## Condition metadata is data frame. It has a column of tissues and a column of contidions, which correspond to columns of the data matrix "expr".
#' col.metadata <- read.table(col.met.path, header=TRUE, row.names=NULL, sep='\t', stringsAsFactors=FALSE)
#' row.met.path <- system.file("extdata/shinyApp/example", "row_metadata.txt", package = "spatialHeatmap")
#' ## Row metadata is a data frame. It has a column of row (gene) annotations, which correspond to rows of the data matrix "expr".
#' row.metadata <- read.table(row.met.path, header=TRUE, row.names=1, sep='\t', stringsAsFactors=FALSE)
#' ## The expression matrix, row metadata, and column metadata are stored in a "SummarizedExperiment" object. The row metadata is optional while column metadata is mandatory. The column names in the expression matrix are not important, since they are ultimately renewed by column metadata.
#' library(SummarizedExperiment); expr <- as.matrix(expr); se <- SummarizedExperiment(assays=list(expr=expr), rowData=row.metadata, colData=col.metadata)  
#' exp <- filter_data(data=se, pOA=c(0, 0), CV=c(0.1, Inf), ann='ann', samples='sample', conditions='condition', dir=NULL) 
#' adj_mod <- adj_mod(data=exp, type="signed", minSize=15, dir=NULL)

#' @section Details:
#' This function builds on "WGCNA" (Langfelder and Horvath 2008) and flashClust (Langfelder and Horvath 2012). First, it computes the adjacency matrix based on the input data matrix, then converts the resulting adjacency matrix to a scale-free topology using a soft threshold (sft). If the type is "signed" sft=12, if the type is "unsigned" sft=6. Next, the modules are identified using dynamic tree cutting algorithm at four sensitivity levels: 0, 1, 2, 3. From 0 to 3, more modules are identified but module sizes are decreasing. In order to enhance the interactive performance of the network feature, modules are only identified at level 2 and 3, since the interactive network functionality in this package works better on smaller modules. Refer to "WGCNA" for more details.

#' @author Jianhai Zhang \email{zhang.jianhai@@hotmail.com; jzhan067@@ucr.edu} \cr Dr. Thomas Girke \email{thomas.girke@@ucr.edu}

#' @references 
#' Langfelder P and Horvath S, WGCNA: an R package for weighted correlation network analysis. BMC Bioinformatics 2008, 9:559 doi:10.1186/1471-2105-9-559 \cr Peter Langfelder, Steve Horvath (2012). Fast R Functions for Robust Correlations and Hierarchical Clustering. Journal of Statistical Software, 46(11), 1-17. URL http://www.jstatsoft.org/v46/i11/ \cr R Core Team (2018). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria. URL https://www.R-project.org/ \cr Peter Langfelder, Bin Zhang and with contributions from Steve Horvath (2016). dynamicTreeCut: Methods for Detection of Clusters in Hierarchical Clustering Dendrograms. R package version 1.63-1. https://CRAN.R-project.org/package=dynamicTreeCut \cr Martin Morgan, Valerie Obenchain, Jim Hester and Hervé Pagès (2018). SummarizedExperiment: SummarizedExperiment container. R package version 1.10.1  

#' @export
#' @importFrom WGCNA adjacency TOMsimilarity 
#' @importFrom flashClust flashClust
#' @importFrom stats quantile dist as.dist
#' @importFrom SummarizedExperiment SummarizedExperiment
#' @importFrom dynamicTreeCut cutreeHybrid


adj_mod <- function(data, type, minSize=15, dir=NULL) {

    if (!is.null(dir)) { path <- paste0(dir, "/local_mode_result/"); if (!dir.exists(path)) dir.create(path) }

    if (type=="signed") sft <- 12; if (type=="unsigned") sft <- 6
    data <- t(assay(data))
    adj <- adjacency(data, power=sft, type=type); diag(adj) <- 0
    tom <- TOMsimilarity(adj, TOMType="signed")
    dissTOM <- 1-tom; tree.hclust <- flashClust(as.dist(dissTOM), method="average")
    ch <- quantile(tree.hclust[['height']], probs=seq(0, 1, 0.05))[19]
    mcol <- NULL; for (ds in 2:3) {
         
        min <- minSize-3*ds; if (min <=5) min <-5
        tree <- cutreeHybrid(dendro=tree.hclust, pamStage=FALSE, minClusterSize=min, cutHeight=ch, deepSplit=ds, distM=dissTOM)
        mcol <- cbind(mcol, tree$labels)

    }; colnames(mcol) <- as.character(2:3); rownames(mcol) <- colnames(adj) <- rownames(adj) <- colnames(data)
    if (!is.null(dir)) { 

      write.table(adj, paste0(path, "adj.txt"), sep="\t", row.names=TRUE, col.names=TRUE)
      write.table(mcol, paste0(path, "mod.txt"), sep="\t", row.names=TRUE, col.names=TRUE)
    
    }; return(list(adj=adj, mod=mcol))

}







