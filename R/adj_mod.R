#' Compute Adjacency Matrix and Identify Modules
#'
#' It designed to compute adjacency matrix and identify modules. The resulting adjacency matrix (adj.txt) and module definition (mod.txt) files are saved in the directory "local_mode_result", which is automatically created in the loction specified by "dir". The computation is computationally intensive for large gene expression matix (e.g. > 10,000 genes). When using the web-browser based Shiny app, the large expression matrix should be computed locally using this function then the resulting files should be uploaded to "Compute locally" in the app.

#' @param data The processed data matrix resulting from the function "filter.data".

#' @param type There are two options in this argument, "signed" and "unsigned". "signed" means both positive and negative adjacency between genes are maintained in network module identification while "unsigned" takes the absolute values of negative adjacency. Refer to "WGCNA" (Langfelder and Horvath 2008) for more details.

#' @param minSize The minimum module size in module identification. The default value is 15. Refer to "WGCNA" for more details.

#' @param dir The location where the directory "local_mode_result/" is created automatically to save resulting files "adj.txt" and "mod.txt". This argument should be the same with that from the function "filter.data" so that the processed data matrix generated by "filter.data" is saved in the same location. 

#' @return The adjacency matrix file "adj.txt" and module assignment file "mod.txt", which are all automatically saved in the directory "local_mode_result."

#' @examples  
#' data.path <- system.file("extdata/example", "root_expr_ann_row_gen.txt", package = "spatialHeatmap")
#' exp <- filter.data(data=data.path, sep="\t", isRowGen=TRUE, pOA=c(0, 0), CV=c(0.1, 10000), dir="./")
#' adj_mod <- adj.mod(data=exp, type="signed", minSize=15, dir="./")

#' @section Details:
#' This function employs "WGCNA" (Langfelder and Horvath 2008) and flashClust (Langfelder and Horvath 2012). First, it computes the adjacency matrix based on the input data matrix, then converts the resulting adjacency matrix to a scale-free topology using a soft threshold (sft). If the type is "signed" sft=12, if the type is "unsigned" sft=6. Next, the modules are identified using dynamic tree cutting algorithm at four sensitivity levels: 0, 1, 2, 3. From 0 to 3, more modules are identified but module sizes are decreasing. In order to enhance the interactive performance, modules are only identified at level 2 and 3, since the interactive network functionality in this package works better on smaller modules. Refer to "WGCNA" for more details.

#' @author Jianhai Zhang \email{zhang.jianhai@@hotmail.com; jzhan067@@ucr.edu} \cr Dr. Thomas Girke \email{thomas.girke@@ucr.edu}

#' @references 
#' Langfelder P and Horvath S, WGCNA: an R package for weighted correlation network analysis. BMC Bioinformatics 2008, 9:559 doi:10.1186/1471-2105-9-559 \cr Peter Langfelder, Steve Horvath (2012). Fast R Functions for Robust Correlations and Hierarchical Clustering. Journal of Statistical Software, 46(11), 1-17. URL http://www.jstatsoft.org/v46/i11/.

#' @export
#' @importFrom WGCNA adjacency TOMsimilarity 
#' @importFrom flashClust flashClust
#' @importFrom stats dist
#' @importFrom stats as.dist
#' @importFrom dynamicTreeCut cutreeHybrid


adj.mod <- function(data, type, minSize=15, dir="./") {

    # require(WGCNA); require(flashClust)
    path <- paste0(dir, "/local_mode_result/")
    if (!dir.exists(path)) dir.create(path)

    if (type=="signed") sft <- 12; if (type=="unsigned") sft <- 6
    data <- t(data[, grep("__", colnames(data)), drop=FALSE])
    adj=adjacency(data, power=sft, type=type); diag(adj)=0
    tom <- TOMsimilarity(adj, TOMType="signed")
    dissTOM=1-tom; tree.hclust=flashClust(as.dist(dissTOM), method="average")
    mcol <- NULL
    for (ds in 2:3) {

        tree <- cutreeHybrid(dendro=tree.hclust, pamStage=FALSE, minClusterSize=(minSize-3*ds), cutHeight=0.99, deepSplit=ds, distM=dissTOM)
        mcol <- cbind(mcol, tree$labels)

    }; colnames(mcol) <- as.character(2:3); rownames(mcol) <- seq_len(nrow(mcol))
    write.table(adj, paste0(path, "adj.txt"), sep="\t", row.names=TRUE, col.names=TRUE)
    write.table(mcol, paste0(path, "mod.txt"), sep="\t", row.names=TRUE, col.names=TRUE)
    adj.mod <- list(adj=adj, mod=mcol); return(adj.mod)

}







