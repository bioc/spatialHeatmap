#' Compute Adjacency Matrix and Identify Modules
#'
#' It first computes an adjacency matrix on the iput data matrix, then hierarchically clusters the adjacency matrix by using WGCNA (Langfelder and Horvath 2008) and flashClust (Langfelder and Horvath 2012). The clutersing includes 4 alternative sensitivity levels (ds=0, 1, 2, or 3). From 3 to 0, the sensitivity decreases and results in less modules with larger sizes. Since the interactive network functionality (see \code{\link{network}}) performs better on smaller modules, only ds of 3 and 2 are used. There is another parameter \code{\link{type}} for module identification: "signed" and "unsinged". The former eans both positive and negative adjacency between genes are used while the latter takes the absolute values of negative adjacency.

#' @param data A \code{data frame} or \code{SummarizedExperiment} object returned by the function \code{\link{filter_data}}, where the columns and rows of the data matrix are samples/conditions and assayed items (e.g. genes, proteins) respectively. Since this function builds on coexpression analysis, variables of sample/condition should be at least 5. Otherwise, the results are not reliable. 
#' @param type Network type. Allowed values are \code{"unsigned"}, \code{"signed"}, \code{"signed hybrid"}, \code{"distance"}. Correlation and distance are transformed as follows: for \code{type="unsigned"}, adjacency=|cor|^power; for \code{type="signed"}, adjacency=(0.5 * (1+cor) )^power; for \code{type="signed hybrid"}, adjacency=cor^power if cor>0 and 0 otherwise; and for \code{type = "distance"}, adjacency=(1-(dist/max(dist))^2)^power. Refer to "WGCNA" (Langfelder and Horvath 2008) for more details. 
#' @param power A numeric of soft thresholding power for generating the adjacency matrix.
#' @param arg.adj A list of additional arguments passed to \code{\link[WGCNA]{adjacency}}, e.g. \code{list(corFnc='cor')}. Default is an empty list \code{list()}.
#' @inheritParams WGCNA::TOMsimilarity
#' @param arg.tom A list of additional arguments passed to \code{\link[WGCNA]{TOMsimilarity}}, e.g. \code{list(verbose=1)}. Default is an empty list \code{list()}.
#' @inheritParams flashClust::flashClust
#' @param minSize The expected minimum module size. The default value is 15. Refer to "WGCNA" for more details.
#' @param arg.cut A list of additional arguments passed to \code{\link[WGCNA]{cutreeHybrid}}, e.g. \code{list(verbose=2)}. Default is an empty list \code{list()}.

#' @param dir The directory path where the folder \code{local_mode_result/} is created automatically to save adjacency matrix and module assignment as tab-sepatated files "adj.txt" and "mod.txt" respectively. This argument should be the same with that from the function \code{\link{filter_data}} so that the "processed_data.txt" generated by \code{\link{filter_data}} is saved in the same location. The default is NULL. This parameter is designed since the computation is intensive for large data matrix (e.g. > 10,000 genes). Therefore, to avoid repetitive computation when using the Shiny app launched by \code{\link{shiny_all}}, "adj.txt" and "mod.txt" can be saved and uploaded to "Compute locally" at a later time.  

#' @return A list containing the adjacency matrix and module assignment, which should be provided to \code{\link{matrix_hm}} and \code{\link{network}}. The adjacency matrix is a measure of co-expression similarity between genes, where larger value denotes more similarity. The module assignment is a data frame. The first column is ds=2 while the second is ds=3. The numbers in each column are module labels with "0" meaning genes not assigned to any modules. If "dir" is specified, both are automatically saved in the folder "local_mode_result" as "adj.txt" and "mod.txt" respectively, which can be uploaded to \code{\link{shiny_all}}. 

#' @examples

#' ## In the following example code, the 2 toy data come from an RNA-seq analysis on developments of 7 chicken organs under 9 time points (Cardoso-Moreira et al. 2019). The complete raw count data are downloaded with the accession number "E-MTAB-6769" using the R package ExpressionAtlas (Keays 2019). Both toy data are generated by truncating the complete data. For conveninece, they are included in this package. Toy data1 is used as a "data frame" input to exemplify data with simple samples/conditions, while toy data2 as "SummarizedExperiment" to illustrate data involving complex samples/conditions.   
#' 
#' ## Set up toy data.
#' 
#' # Access the toy data1.
#' cnt.chk.simple <- system.file('extdata/shinyApp/example/count_chicken_simple.txt', package='spatialHeatmap')
#' df.chk <- read.table(cnt.chk.simple, header=TRUE, row.names=1, sep='\t', check.names=FALSE)
#' # Note the naming scheme "sample__condition" in columns, where "sample" and "condition" stands for organs and time points respectively.
#' df.chk[1:3, ]
#' 
#' # A column of gene annotation can be appended to the data frame, but is not required.  
#' ann <- paste0('ann', seq_len(nrow(df.chk))); ann[1:3]
#' df.chk <- cbind(df.chk, ann=ann)
#' df.chk[1:3, ]
#'
#' # Access the toy data2. 
#' cnt.chk <- system.file('extdata/shinyApp/example/count_chicken.txt', package='spatialHeatmap')
#' count.chk <- read.table(cnt.chk, header=TRUE, row.names=1, sep='\t')
#' count.chk[1:3, 1:5]
#'
#' # A targets file is required for toy data2. It should be made based on the experiment design, which is accessible through the accession number "E-MTAB-6769" in R package ExpressionAtlas. The completed targets file is included in this package. 

#' # Access the targets file. 
#' tar.chk <- system.file('extdata/shinyApp/example/target_chicken.txt', package='spatialHeatmap')
#' target.chk <- read.table(tar.chk, header=TRUE, row.names=1, sep='\t')
#' # Note every column in toy data2 corresponds with a row in targets file. 
#' target.chk[1:5, ]
#' # Store toy data2 in "SummarizedExperiment".
#' library(SummarizedExperiment)
#' se.chk <- SummarizedExperiment(assay=count.chk, colData=target.chk)
#' # The "rowData" slot can store a data frame of gene annotation, but not required.
#' rowData(se.chk) <- DataFrame(ann=ann)
#'
#' ## As conventions, sequencing count data should be normalized, aggregated, and filtered fo reduce noise. In the following, the two toy data are used in the same way. For simplicity, only toy data2 is illustrated.
#'
#' # The normalizing function "calcNormFactors" (McCarthy et al. 2012) with default settings is used.  
#' se.nor.chk <- norm_data(data=se.chk, norm.fun='CNF', data.trans='log2')

#' # Aggregate "sample__condition" replicates in toy data2, where "sample" is "organism_part" and "condition" is "age". 
#' se.aggr.chk <- aggr_rep(data=se.nor.chk, sam.factor='organism_part', con.factor='age', aggr='mean')
#' assay(se.aggr.chk)[1:3, 1:3]

#' # Filter genes with low counts and low variance. Genes with counts over 5 (log2 unit) in at least 1% samples (pOA), and coefficient of variance (CV) between 0.2 and 100 are retained.
#' se.fil.chk <- filter_data(data=se.aggr.chk, sam.factor='organism_part', con.factor='age', pOA=c(0.01, 5), CV=c(0.2, 100), dir=NULL)
#'
#' ## Identify modules.
#' adj.mod <- adj_mod(data=se.fil.chk)
#' # The adjacency matrix is a measure of co-expression similarity between genes, where larger value denotes more similarity.
#' adj.mod[['adj']][1:3, 1:3]
#' # The module assignment is a data frame. The first column is ds=2 while the second is ds=3. The numbers in each column are module labels with "0" meaning genes not assigned to any modules.
#' adj.mod[['mod']][1:3, ]

#' @section Details:
#' This function builds on "WGCNA" (Langfelder and Horvath 2008) and flashClust (Langfelder and Horvath 2012). First, it computes an adjacency matrix based on the input data matrix, then converts the resulting adjacency matrix to a scale-free topology using a soft thresholding power (sft). Next, the modules are identified using dynamic tree cutting algorithm at four sensitivity levels (ds): 0, 1, 2, 3. From 0 to 3, more modules are identified but module sizes are decreasing. In order to enhance the interactive performance of the network functionality, modules are only identified at level 2 and 3, since the interactive network in this package works better on smaller modules. Refer to \code{\link{network}} for more details.

#' @author Jianhai Zhang \email{zhang.jianhai@@hotmail.com; jzhan067@@ucr.edu} \cr Dr. Thomas Girke \email{thomas.girke@@ucr.edu}

#' @references 
#' Langfelder P and Horvath S, WGCNA: an R package for weighted correlation network analysis. BMC Bioinformatics 2008, 9:559 doi:10.1186/1471-2105-9-559 \cr Peter Langfelder, Steve Horvath (2012). Fast R Functions for Robust Correlations and Hierarchical Clustering. Journal of Statistical Software, 46(11), 1-17. URL http://www.jstatsoft.org/v46/i11/ \cr R Core Team (2018). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria. URL https://www.R-project.org/ \cr Peter Langfelder, Bin Zhang and with contributions from Steve Horvath (2016). dynamicTreeCut: Methods for Detection of Clusters in Hierarchical Clustering Dendrograms. R package version 1.63-1. https://CRAN.R-project.org/package=dynamicTreeCut \cr Martin Morgan, Valerie Obenchain, Jim Hester and Hervé Pagès (2018). SummarizedExperiment: SummarizedExperiment container. R package version 1.10.1 
#' Keays, Maria. 2019. ExpressionAtlas: Download Datasets from EMBL-EBI Expression Atlas
#' Love, Michael I., Wolfgang Huber, and Simon Anders. 2014. "Moderated Estimation of Fold Change and Dispersion for RNA-Seq Data with DESeq2." Genome Biology 15 (12): 550. doi:10.1186/s13059-014-0550-8
#' Cardoso-Moreira, Margarida, Jean Halbert, Delphine Valloton, Britta Velten, Chunyan Chen, Yi Shao, Angélica Liechti, et al. 2019. “Gene Expression Across Mammalian Organ Development.” Nature 571 (7766): 505–9 

#' @export
#' @importFrom WGCNA adjacency TOMsimilarity 
#' @importFrom flashClust flashClust
#' @importFrom stats quantile dist as.dist
#' @importFrom SummarizedExperiment SummarizedExperiment
#' @importFrom dynamicTreeCut cutreeHybrid


adj_mod <- function(data, type='signed', power=if (type=='distance') 1 else 6, arg.adj=list(), TOMType='unsigned', arg.tom=list(), method='complete', minSize=15, arg.cut=list(), dir=NULL) {

  options(stringsAsFactors=FALSE)
  # Get data matrix.
  if (is(data, 'data.frame')|is(data, 'matrix')|is(data, 'DFrame')) {

    data <- as.data.frame(data); rna <- rownames(data); cna <- make.names(colnames(data)) 
    if (any(duplicated(cna))) stop('Please use function \'aggr_rep\' to aggregate replicates!')
    na <- vapply(seq_len(ncol(data)), function(i) { tryCatch({ as.numeric(data[, i]) }, warning=function(w) { return(rep(NA, nrow(data)))
    }, error=function(e) { stop("Please make sure input data are numeric!") }) }, FUN.VALUE=numeric(nrow(data)) )
    na <- as.data.frame(na); rownames(na) <- rna
    idx <- colSums(apply(na, 2, is.na))!=0
    data <- na[!idx]; colnames(data) <- cna[!idx]; data <- t(data)

  } else if (is(data, 'SummarizedExperiment')) { data <- t(assay(data)) 

    if (any(duplicated(rownames(data)))) stop('Please use function \'aggr_rep\' to aggregate replicates!')

  }; if (nrow(data)<5) cat('Warning: variables of sample/condition are less than 5! \n')

  if (ncol(data)>10000) cat('More than 10,000 rows are detected in data. Computation may take a long time! \n')
  
  # Compute adjacency matrix.
  arg.adj <- c(list(datExpr=data, power=power, type=type), arg.adj)
  adj <- do.call(adjacency, arg.adj)
  # Compute TOM and hierarchical clustering.
  arg.tom <- c(list(adjMat=adj, TOMType=TOMType), arg.tom)
  tom <- do.call(TOMsimilarity, arg.tom)
  dissTOM <- 1-tom; tree.hclust <- flashClust(d=as.dist(dissTOM), method=method)
  # Cut the tree to get modules.
  cutHeight <- quantile(tree.hclust[['height']], probs=seq(0, 1, 0.05))[19]
  arg.cut1 <- list(dendro=tree.hclust, pamStage=FALSE, cutHeight=cutHeight, distM=dissTOM)
  na.cut1 <- names(arg.cut1); na.cut <- names(arg.cut)
  if ('deepSplit' %in% na.cut) arg.cut <- arg.cut[!(na.cut %in% 'deepSplit')]
  w <- na.cut1 %in% na.cut
  arg.cut1 <- c(arg.cut1[!w], arg.cut)
  mcol <- NULL; for (ds in 2:3) {
         
    min <- as.numeric(minSize)-3*ds; if (min < 5) min <- 5
    arg.cut <- c(list(minClusterSize=min, deepSplit=ds), arg.cut1)
    tree <- do.call(cutreeHybrid, arg.cut)
    mcol <- cbind(mcol, tree$labels); arg.cut <- list()

  }; colnames(mcol) <- as.character(2:3); rownames(mcol) <- colnames(adj) <- rownames(adj) <- colnames(data)
  if (!is.null(dir)) { 

    path <- paste0(dir, "/local_mode_result/"); if (!dir.exists(path)) dir.create(path)
    write.table(adj, paste0(path, "adj.txt"), sep="\t", row.names=TRUE, col.names=TRUE)
    write.table(mcol, paste0(path, "mod.txt"), sep="\t", row.names=TRUE, col.names=TRUE)
    
  }; return(list(adj=adj, mod=mcol))

}






