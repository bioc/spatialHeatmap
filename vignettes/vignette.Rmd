---
title: "_spatialHeatmap_: Visualizing Spatial Assays in Anatomical Images and Network Graphs"
author: "Authors: Jianhai Zhang, Bing Yang, Wolf B. Frommer, Julia Bailey-Serres and Thomas Girke"
date: "Last update: `r format(Sys.time(), '%d %B, %Y')`"
output:
  BiocStyle::html_document:
    css: file/custom.css
    toc: true
    toc_float:
        collapsed: true
        smooth_scroll: true
    toc_depth: 4
    fig_caption: yes
    code_folding: show
    number_sections: true
    self_contained: true
fontsize: 14pt
bibliography: bibtex.bib
package: spatialHeatmap
vignette: >
  %\VignetteIndexEntry{spatialHeatmap: Visualizing Spatial Assays in Anatomical Images and Network Graphs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{css, echo=FALSE}
pre code {
white-space: pre !important;
overflow-x: scroll !important;
word-break: keep-all !important;
word-wrap: initial !important;
}
```

```{r global_options, include=FALSE}
## ThG: chunk added to enable global knitr options. The below turns on
## caching for faster vignette re-build during text editing.
knitr::opts_chunk$set(cache=TRUE)
```
<!-- 

<style type="text/css">
 .main-container { max-width: 1800px; margin-left: 5px; margin-right: auto; }
</style>

<style>body { text-align: justify }</style>  


```{r css, echo = FALSE, results = 'asis'}
BiocStyle::markdown(css.files=c('file/custom.css'))
```

-->

```{r setup0, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr); opts_chunk$set(message=FALSE, warning=FALSE)
```

<font color='red'>[Comment-Thomas: note, to-dos are now mostly listed in margin notes
on right.]</font> 

# Introduction 

## Motivation

The _spatialHeatmap_ package provides functionalities for visualizing cell-,
tissue- and organ-specific data of biological assays by coloring the
corresponding spatial features defined in anatomical images according to a
numeric color key. The color scheme used to represent the assay values can be
customized by the user. This core functionality of the package is called a
_spatial heatmap_ (SHM) plot. It is enhanced with nearest neighbor
visualization tools for groups of measured items (_e.g._ gene modules) sharing
related abundance profiles, including matrix heatmaps combined with
hierarchical clustering dendrograms and network representations.  The
functionalities of _spatialHeatmap_ can be used either in a command-driven mode
from within R or a graphical user interface (GUI) provided by a Shiny App that
is also part of this package. While the R-based mode provides flexibility to
customize and automate analysis routines, the Shiny App includes a variety of
convenience features that will appeal to experimentalists and other users less
familiar with R. Moreover, the Shiny App can be used on both local computers as
well as centralized server-based deployments (_e.g._ cloud-based or custom
servers) that can be accessed remotely as a public web service for using
_spatialHeatmap's_ functionalities with community and/or private data. The
functionalities of the `spatialHeatmap` package are illustrated in Figure
\@ref(fig:illus).   


```{r illus, echo=FALSE, fig.wide=TRUE, fig.cap=("Functionality overview. The numeric data can come as a `vector`, `data frame`, or `SummarizedExperiment` (SE). If `vector` or `data frame`, the sample and condition identifiers should be in the form of \'sample__condition\', e.g. \'S1__con1\'. If `data frame` or SE, the columns and rows should be sample/conditions and assayed items (gene1, gene2) respectively. In SE, the `colData` slot is required and contains replicate information, while the `rowData` slot is optional and contains row item annotation. If the latter is available, the annotation is seen by mousing over a node in the interactive network. In the aSVG image (see [aSVG](#term) below), spatial features are pre-defined and assigned unique identifiers. In visualization, only aSVG features having identical sample counterparts in data are colored (*e.g.* S1) in SHMs. To supplement SHMs, coexpression analysis is applied on \'data matrix\' to identify network modules. The gene in SHMs can be investigated in the gene module it belongs to, where the module is in form of matrix heatmap and network. Lastly, the SHMs, matrix heatmap, network are all combined as an interactive Shiny app."), out.width="100%"}

include_graphics('img/illustration.png')

```
^[Thomas-Comment: the legend text of Figure 1 should provide a brief overview of what is shown
in the flowchart. Right now there is too much technical detail that lacks context.
I suggest to significantly shorten it. Also, you may want to organize the flowchart
with bullet labels like (A), (B), (C) and (D) that can be referenced in the text. 
For instance: (A) Expression Data, (B) aSVG, (C) SHM and (D) Gene Context Plots. 
This way there is a clear label plus a visual illustration for each component one
can refer to in the text with Figure 1A or Figure 1B, etc.]

As anatomical images the package supports both tissue maps from public
repositories and custom images provided by the user. In general any type of
image can be used as long as it can be provided in SVG (Scalable Vector
Graphics) format, where the corresponding spatial features have been defined
(see [aSVG](#term) below). The numeric values plotted onto an SHM
are usually quantitative measurements from a wide range of profiling
technologies, such as microarrays, next generation sequencing (_e.g._ RNA-Seq
and scRNA-Seq), proteomics, metabolomics, or many other small- or large-scale
experiments. For convenience, several preprocessing and normalization methods
for the most common use cases are included that support raw and/or preprocessed
data. Currently, the main application domains of the _spatialHeatmap_ package
are numeric data sets and spatially mapped images from biological, agricultural
and biomedical areas. Moreover, the package has been designed to also work with
many other spatial data types, such a population data plotted onto geographic
maps. This high level of flexibility is one of the unique features of
_spatialHeatmap_. Related software tools for biological applications in this
field are largely based on pure web applications [@Winter2007-bq;
@Waese2017-fx] or local tools [@Maag2018-gi; @Muschelli2014-av] that typically
lack customization functionalities. These restrictions limit users to utilizing
pre-existing expression data and/or fixed sets of anatomical image collections.
To close this gap for biological use cases, we have developed _spatialHeatmap_
as a generic R/Bioconductor package for plotting quantitative values onto any
type of spatially mapped images in a programmable environment and/or in an
intuitive to use GUI application.

## Design {#design}

The core feature of [`spatialHeatmap`](#shm) is to map the assay values (_e.g._
gene expression data) of one or many items (_e.g._ genes) measured under
different conditions in form of numerically graded colors onto the
corresponding cell types or tissues represented in a chosen SVG image. In the
gene profiling field, this feature supports comparisons of the expression
values among multiple genes by plotting their SHMs next to each
other. Similarly, one can display the expression values of a single or multiple
genes across multiple conditions in the same plot (Figure \@ref(fig:humshm)). This level of flexibility is
very efficient for visualizing complicated expression patterns across genes,
cell types and conditions. In case of more complex anatomical images composed
of overlapping multiple layer tissues, it is important to visually expose the
tissue layer of interest in the plots. To address this, several default and
customizable layer viewing options are provided. They allow to hide features in
the top layers by making them transparent in order to expose features below
them. This transparency viewing feature is highlighted below in the mouse
example (Figure \@ref(fig:musshm1)).

To maximize reusability and extensibility, the package organizes large-scale
omics assay data along with the associated experimental design information in a
`SummarizedExperiment` object. The latter is one of the core S4 classes within
the Bioconductor ecosystem that has been widely adapted by many other software
packages dealing with gene-, protein- and metabolite-level profiling data
[@SummarizedExperiment]. In case of gene expression data, the `assays` slot of
the `SummarizedExperiment` container is populated with a gene expression
matrix, where the rows and columns represent the genes and tissue/conditions,
respectively, while the `colData` slot contains metadata including replicate
information. The tissues and/or cell type information in the object maps via
`colData` to the corresponding features in the SVG images using unique
identifiers for the spatial features (_e.g._ tissues or cell types). This
allows to color the features of interest in an SVG image according to the
numeric data stored in a `SummarizedExperiment` object. For simplicity the
numeric data can also be provided as numeric `vectors` or `data.frames`. This
can be useful for testing purposes and/or the usage of simple data sets that
may not require the more advanced features of the `SummarizedExperiment` class,
such as measurements with only one or a few data points. Details about how to
access the SVG images and properly format the associated expression data are
provided in the [Supplement section](#data_form) of this vignette.

## Image Format: SVG {#term}
SHMs are images where colors encode numeric values in features of
any shape. For plotting SHMs, Scalable Vector Graphics (SVG) has
been chosen as image format since it is a flexible and widely adapted vector
graphics format that provides many advantages for computationally embedding
numerical and other information in images. SVG is based on XML formatted text
describing all components present in images, including lines, shapes and
colors. In case of biological images suitable for SHMs, the shapes
often represent anatomical or cell structures. To assign colors to specific
features in SHMs, _annotated SVG_ (aSVG) files are used where the
shapes of interest are labeled according to certain conventions so that they
can be addressed and colored programmatically. SVGs and aSVGs of anatomical structures can
be downloaded from many sources including the repositories described [below](#data_sources).
Alternatively, users can generate them themselves with vector graphics software
such as [Inkscape](https://inkscape.org/). Typically, in aSVGs one or more 
shapes of a feature of interest, such as the cell shapes of an organ, are
grouped together by a common feature identifier. Via these group identifiers
one or many feature types can be colored simultaneously in an aSVG according to
biological experiments assaying the corresponding feature types with the
required spatial resolution. Correct assignment of image features and assay
results is assured by using for both the same feature identifiers. The color
gradient used to visually represent the numeric assay values is controlled by a
color gradient parameter. To visually interpret the meaning of the colors, the
corresponding color key is included in the SHM plots.  Additional
details for properly formatting and annotating both aSVG images and assay data
are provided in the [Supplement](#sup) section of this vignette. 

## Data Repositories {#data_sources}

If not generated by the user, SHMs can be generated with data
downloaded from various public repositories. This includes gene, protein and
metabolic profiling data from databases, such as GEO, BAR and EBI. A
particularly useful resource, when working with `spatialHeatmap`, is the Expression
Atlas from EMBL-EBI [@Papatheodorou2018-jy]. This online service contains both assay and
anatomical images. Its assay data include mRNA and protein profiling
experiments for different species, tissues and conditions. The corresponding
anatomical image collections are also provided for a wide range of species
including animals and plants. In `spatialHeatmap` several import functions are
provided to work with the expression and [aSVG repository](#svg_repo) from the Expression Atlas
directly. The aSVG images developed by the `spatialHeatmap` project are available in its own
repository called [spatialHeatmap aSVG Repository](https://github.com/jianhaizhang/SVG_tutorial_file/tree/master/svg_repo), 
where users can contribute their aSVG images that are formatted according to our guidlines.

## Tutorial Overview {#sample_data}

The following sections of this vignette showcase the most important
functionalities of the `spatialHeatmap` package using as initial example a simple
to understand toy data set, and then more complex mRNA profiling data from the
Expression Atlas and GEO databases. First, SHM plots are generated for both the toy
and mRNA expression data. The latter include gene expression data sets from
RNA-Seq and microarray experiments of [Human Brain](#hum), [Mouse
Organs](#mus), [Chicken Organs](#chk), and [Arabidopsis Shoots](#shoot). The
first three are RNA-Seq data from the [Expression
Atlas](https://www.ebi.ac.uk/gxa/home), while the last one is a microarray data
set from [GEO](https://www.ncbi.nlm.nih.gov/geo/).  Second, gene context
analysis tools are introduced, which facilitate the visualization of
gene modules sharing similar expression patterns. This includes the
visualization of hierarchical clustering results with traditional matrix
heatmaps ([Matrix Heatmap](#mhm)) as well co-expression network plots
([Network](#net)). Third, an overview of the corresponding [Shiny App](#shiny)
is presented that provides access to the same functionalities as the R
functions, but executes them in an interactive GUI environment [@shiny;
@shinydashboard]. Fourth, more advanced features for plotting customized
SHMs are covered using the Human Brain data set as an example.  


# Getting Started  

## Installation  

The `spatialHeatmap` package should be installed from an R (version $\ge$ 3.6)
session with the `BiocManager::install` command.  

```{ eval=FALSE, echo=TRUE, warnings=FALSE} 
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("spatialHeatmap")
```

## Packages and Documentation

Next, the packages required for running the sample code in this vignette need to be loaded.  

```{r, eval=TRUE, echo=TRUE, warnings=FALSE}
library(spatialHeatmap); library(SummarizedExperiment); library(ExpressionAtlas); library(GEOquery)
```

The following lists the vignette(s) of this package in an HTML browser. Clicking the corresponding name will open this vignette. 

```{r, eval=FALSE, echo=TRUE, warnings=FALSE}
browseVignettes('spatialHeatmap')
```

# Spatial Heatmaps (SHMs) {#shm}


## Toy Example {#toy}

SHMs are plotted with the `spatial_hm` function. To provide a quick
and intuitive overview how these plots are generated, the following uses a
generalized toy example where a small vector of random numeric values is
generated that are used to color features in an aSVG image. The image chosen
for this example is an aSVG depicting the human brain. The corresponding image
file 'homo_sapiens.brain.svg' is included in this package for testing purposes.
The path to this image on a user\'s system, where `spatialHeatmap` is
installed, can be obtained with the `system.file` function.

### aSVG Image

The following commands obtain the directory of the aSVG collection and the full path 
to the chosen target aSVG image on a user's system, respectively.

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
svg.dir <- system.file("extdata/shinyApp/example", package="spatialHeatmap")
svg.hum <- system.file("extdata/shinyApp/example", 'homo_sapiens.brain.svg', package="spatialHeatmap")
```

To identify features of interest in annotated aSVG images, the `return_feature` function
can be used. The following searches the aSVG images stored in `dir` for the query terms
'lobe' and 'homo sapiens' under the `feature` and `species` fields, respectively. The identified 
matches are returned as a `data.frame`.   


```{r eval=TRUE, echo=TRUE, warnings=FALSE }
feature.df <- return_feature(feature=c('lobe'), species=c('homo sapiens'), remote=FALSE, dir=svg.dir)
feature.df
fnames <- feature.df[, 1]
```

### Numeric Data

The following example generates a small numeric toy vector, where the data slot
contains four numbers and its name slot is populated with the three feature
names obtained from the above aSVG image. In addition, a non-matching entry
(here 'notMapped') is included for demonstration purposes. Note, the numbers
are mapped to features via matching names among the numeric vector and the aSVG,
respectively. Accordingly, only numbers and features with matching name
counterparts can be colored in the aSVG image.  Entries without name matches
are indicated by a message printed to the R console, here "notMapped". This
behavior can be turned off with `verbose=FALSE` in the corresponding function
call. In addition, a summary of the numeric assay to feature mappings is stored
in the result `data.frame` returned by the `spatial_hm` function (see below). 


```{r eval=TRUE, echo=TRUE, warnings=FALSE }
my_vec <- sample(1:100, length(unique(fnames))+1)
names(my_vec) <- c(unique(fnames), 'notMapped')
my_vec
```

### Plot SHM

Next, the SHM is plotted with the `spatial_hm` function (Figure
\@ref(fig:toyshm)). Internally, the numbers in `my_vec` are translated to
colors based on the color key assigned to the `col.com` argument, and then
painted onto the corresponding features in the aSVG, where the path to the image
file is defined by `svg.path=svg.hum`. The remaining arguments used here include:
`ID` for defining the title of the plot; `ncol` for setting the column-wise layout 
of the plot excluding the feature legend plot on the right; and `height` for defining 
the height of the SHM relative to its width. In the given example
(Figure \@ref(fig:toyshm)) only three features in `my_vec` ('occipital lobe', 
'parietal lobe', and 'temporal lobe') have matching entries in the corresponding 
aSVG. 

```{r toyshm, eval=TRUE, echo=TRUE, warnings=FALSE, fig.wide=TRUE, fig.cap=("SHM of human brain with toy data. The plots from left to right represent color key, SHM and legend. The colors in the first two plots depict the user provided numeric values, whereas in the legend plot they are used to map the feature labels to the corresponding spatial regions in the image. "), out.width="100%" }
shm.df <- spatial_hm(svg.path=svg.hum, data=my_vec, ID='toy', ncol=1, height=0.7, sub.title.size=20)
```

The named numeric values in `my_vec`, that have name matches with the features in the 
chosen aSVG, are stored in the `mapped_feature` slot.

```{r eval=TRUE, echo=TRUE, warnings=FALSE} 
# The SHM and mapped features are stored in a list
names(shm.df)
# Mapped features
shm.df[['mapped_feature']]
```

## Human Brain {#hum} 

This subsection introduces how to find cell- and tissue-specific assay data in
the Expression Atlas database. After choosing a gene expression experiment, the
data is downloaded directly into a user\'s R session. Subsequently, the 
expression values for selected genes can be plotted onto a chosen aSVG image with 
or without prior preprocessing steps (_e.g._ normalization). For querying and 
downloading expression data from the Expression Atlas database, functions from 
the `ExpressionAtlas` package are used [@ebi]. 

### Gene Expression Data

The following example searches the Expression Atlas for expression data derived from
specific tissues and species of interest, here _'cerebellum'_ and _'Homo sapiens'_,
respectively.

```{r eval=TRUE, echo=TRUE, message=FALSE, warnings=FALSE }
all.hum <- searchAtlasExperiments(properties="cerebellum", species="Homo sapiens")
```

The search result is stored in a `DFrame` containing `r nrow(all.hum)`
accessions matching the above query. For the following sample code, the
accession
'[E-GEOD-67196](https://www.ebi.ac.uk/arrayexpress/experiments/E-GEOD-67196/)'
from Prudencio _et al._ [-@Prudencio2015-wd] has been chosen, which corresponds
to an RNA-Seq profiling experiment of _'cerebellum'_ and _'frontal cortex'_ brain
tissue from patients with amyotrophic lateral sclerosis (ALS). Details about the
corresponding record can be returned as follows.

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
all.hum[2, ]
```

The `getAtlasData` function allows to download the chosen RNA-Seq experiment
from the Expression Atlas and import it into a `RangedSummarizedExperiment`
object of a user\'s R session.   


```{r eval=TRUE, echo=TRUE, warnings=FALSE }
rse.hum <- getAtlasData('E-GEOD-67196')[[1]][[1]]
```

The design of the downloaded RNA-Seq experiment is described in the `colData` slot of 
`rse.hum`. The following returns only its first five rows and columns.

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
colData(rse.hum)[1:5, 1:5]
```

### aSVG Image  

The following example shows how to download from the [EBI SVG
repository](#svg_repo) an aSVG image that matches the tissues and species
assayed in the gene expression data set downloaded in the previous subsection.
The `return_feature` function queries the repository for feature- and
species-related keywords, here `c('frontal cortex', 'cerebellum')` and
`c('homo sapiens', 'brain')`, respectively. To return aSVGs with at least one
feature and one species match, the argument `keywords.any` is set to `TRUE` by
default. When `return.all=FALSE`, only aSVGs matching the query keywords are returned
and saved under `dir`. Otherwise, all aSVGs are returned regardless of the
keywords. To avoid overwriting of existing SVG files, it is recommended to
start with an empty target directory, here `~/test`. To search a local
directory for matching aSVG images, the argument setting `remote=FALSE` needs
to be used, while specifying the path of the corresponding directory under
`dir`.  All or only matching features are returned if `match.only` is set to
`FALSE` or `TRUE`, respectively.


```{r eval=FALSE, echo=TRUE, warnings=FALSE }
dir.create('~/test') # Create empty directory
feature.df <- return_feature(feature=c('frontal cortex', 'cerebellum'), species=c('homo sapiens', 'brain'), keywords.any=TRUE, return.all=FALSE, dir='~/test', remote=TRUE, match.only=TRUE, desc=FALSE) # Query aSVGs
feature.df[1:8, ] # Return first 8 rows for checking
unique(feature.df$SVG) # Return all matching aSVGs
```

To build this vignettes according to the R/Bioconductor package requirements, the
following code section uses the aSVG file instance included in the
`spatialHeatmap` package rather than the downloaded instance from the previous
example. 


```{r eval=TRUE, echo=TRUE, warnings=FALSE }
feature.df <- return_feature(feature=c('frontal cortex', 'cerebellum'), species=c('homo sapiens', 'brain'), keywords.any=TRUE, return.all=FALSE, dir=svg.dir, remote=FALSE)
```

Note, the target tissues `frontal cortex` and `cerebellum` are included in both
the experimental design slot of the downloaded expression data as well as the 
annotations of the aSVG. This way these features can be colored in the downstream
SHM plots. If necessary users can also change from within R the feature identifiers 
and names in an aSVG. Details on this utility are provided in the [Supplement](#update).  

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
feature.df
```

Since the Expression Atlas supports the [cross-species anatomy
ontology](http://uberon.github.io/), the corresponding UBERON identifiers are
included in the `id` column of the `data.frame` returned by the above function
call of `return_feature` [@Mungall2012-ma]. This ontology is also supported
by the `rols` Bioconductor package [@rols].


### Experimental Design

For organizing experimental designs and downstream plotting purposes, it can be
desirable to shorten the text in certain columns of `colData`. This way one can
use the source data for displaying 'pretty' sample names in columns and legends
of all downstream tables and plots, respectively, in a consistent and automated
manner. To achieve this, the following example imports a 'targets' file that
can be generated and edited by the user in a text or spreadsheet program. In
the following example the target file content is used to replace the text in the
`colData` slot with a shortened version. 


The following imports a custom target file containing simplified sample labels 
and experimental design information.

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
hum.tar <- system.file('extdata/shinyApp/example/target_human.txt', package='spatialHeatmap')
target.hum <- read.table(hum.tar, header=TRUE, row.names=1, sep='\t')
```

Load custom target data into `colData` slot.  

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
colData(rse.hum) <- DataFrame(target.hum)
```

A slice of the simplified `colData` object is shown below, where the `disease`
column contains now shorter labels than in the original data set. Additional
details for generating and using target files in `spatialHeatmap` are provided
in the [Supplement](#data_form) of this vignette.  


```{r eval=TRUE, echo=TRUE, warnings=FALSE}
colData(rse.hum)[c(1:3, 41:42), 4:5]
```

### Preprocess Assay Data

The actual gene expression data of the downloaded RNA-Seq experiment is stored
in the `assay` slot of `rse.hum`. Since it contains raw count data, it can be
desirable to apply basic preprocessing routines prior to plotting spatial
heatmaps. The following shows how to normalize the count data, aggregate
replicates and then remove genes with unreliable expression responses.  These
preprocessing steps are optional and can be skipped if needed. For this,
the expression data can be provided to the `spatial_hm` function directly, where
it is important to assign to the `sam.factor` and/or `con.factor` arguments 
the corresponding sample and/or condition column names (Table \@ref(tab:arg)).  

For normalizing raw count data from RNA-Seq experiments, the `norm_data`
function can be used. It supports the following pre-existing functions from
widely used packages for analyzing count data in the next generation sequencing
(NGS) field: `calcNormFactors` (CNF) from `edgeR` [@edgeR]; as well as
`estimateSizeFactors` (EST),  `varianceStabilizingTransformation` (VST), and
`rlog` from DESeq2 [@DESeq2].  The argument `norm.fun` specifies one of the
four internal normalizing methods: `CNF`, `EST`, `VST`, and `rlog`. If
`norm.fun='none'`, no normalization is applied.  The arguments for each
normalizing function are provided via a `parameter.list`, which is a `list`
with named slots. For example, `norm.fun='ESF'` and
`parameter.list=list(type='ratio')` is equivalent to
`estimateSizeFactors(object, type='ratio')`.  If `paramter.list=NULL`, the
default arguments are used by the normalizing function assigned to `norm.fun`.
For additional details, users want to consult the help file of the `norm_data`
function by typing `?norm_data` in the R console. 

The following example uses the `ESF` normalization option. This method has been 
chosen mainly due to its good time performance.   

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
se.nor.hum <- norm_data(data=rse.hum, norm.fun='ESF', data.trans='log2')
```

Replicates are aggregated with the `aggr_rep` function, where the summary
statistics can be chosen under the `aggr` argument (_e.g._ `aggr='mean'`). The
columns specifying replicates can be assigned to the `sam.factor` and
`con.factor` arguments corresponding to samples and conditions, respectively.
For tracking, the corresponding sample/condition labels are used as column
titles in the aggregated `assay` instance, where they are concatenated with a
double underscore as separator. In addition, the corresponding rows in the
`colData` slot are collapsed accordingly.


```{r eval=TRUE, echo=TRUE, warnings=FALSE }
se.aggr.hum <- aggr_rep(data=se.nor.hum, sam.factor='organism_part', con.factor='disease', aggr='mean')
assay(se.aggr.hum)[1:3, ]
```

To remove unreliable expression measures, filtering can be applied.
The following example eliminates genes with expression values
larger than 5 (log2 space) in at least 1% of all samples (`pOA=c(0.01, 5)`), while
retaining genes with a coefficient of variance (CV) between 0.30 and 100 
(`CV=c(0.30, 100)`).  

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
se.fil.hum <- filter_data(data=se.aggr.hum, sam.factor='organism_part', con.factor='disease', pOA=c(0.01, 5), CV=c(0.3, 100), dir=NULL)
```

To inspect the results, the following returns three selected rows of the fully
preprocessed data matrix (Table \@ref(tab:humtab)). 

```{r eval=FALSE, echo=TRUE, warnings=FALSE }
assay(se.fil.hum)[c(5, 733:734), ]
```

```{r humtab, eval=TRUE, echo=FALSE, warnings=FALSE}
kable(assay(se.fil.hum)[c(5, 733:734), ], caption='Slice of fully preprocessed expression matrix.')
```

### SHM: Single Gene

The preprocessed expression values for any gene in the `assay` slot of
`se.fil.hum` can be plotted as a SHM. The following uses gene
`ENSG00000268433` as an example. The chosen aSVG is a depiction of the human
brain where the assayed featured are colored by the corresponding expression
values in `se.fil.hum`.  

<a name='hum_single'></a>
```{r humshm, eval=TRUE, echo=TRUE, warnings=FALSE, fig.wide=TRUE, fig.cap=("SHM of human brain. Only cerebellum and frontal cortex are colored, because they are present in both the aSVG and the expression data. The legend plot on the right maps the feature labels to the corresponding spatial regions in the image."), out.width="100%" }
shm.df <- spatial_hm(svg.path=svg.hum, data=se.fil.hum, ID=c('ENSG00000268433'), height=0.6, legend.r=1.3)
```

The plotting instructions of the SHM along with the corresponding 
mapped features are stored in a `list` named `shm.df`. Its components
can be accessed as follows.

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
names(shm.df)
# Mapped features
shm.df[['mapped_feature']]
```

In the above example, the normalized expression values of gene `ENSG00000268433` 
are colored in the frontal cortex and cerebellum, while the different conditions, 
here normal and ALS, are given in separate SHMs plotted next to 
each other (Figure \@ref(fig:humshm)). The color and feature mappings are defined
by the corresponding color key and legend plot on the left and right, respectively.

### SHM: Multiple Genes

SHMs for multiple genes can be plotted by providing the
corresponding gene IDs under the `ID` argument as a character vector. The
`spatial_hm` function will then sequentially arrange the SHMs for
each gene in a single composite plot. To facilitate comparisons of expression
values across genes and/or conditions, the `lay.shm` parameter can be assigned
`'gene'` or `'con'`, respectively. For instance, in Figure \@ref(fig:mul) the
SHMs of the genes `ENSG00000268433` and `ENSG00000006047` are organised
by condition in a horizontal view. This functionality is particularly useful when
comparing gene families. 

```{r mul, eval=TRUE, echo=TRUE, warnings=FALSE, fig.wide=TRUE, fig.cap=("SHMs of two genes. The subplots are organised by \"condition\" through `lay.shm` argument."), out.width="100%" }
spatial_hm(svg.path=svg.hum, data=se.fil.hum, ID=c('ENSG00000268433', 'ENSG00000006047'), lay.shm='con', width=1, height=1, legend.r=1.5)
```

### SHM: Customization

To provide a high level of flexibility, the `spatial_hm` contains many arguments.
An overview of the argument names and their utility is provide in Table \@ref(tab:arg).

```{r arg, eval=TRUE, echo=FALSE, warnings=FALSE}
arg.df <- read.table('file/spatial_hm_arg.txt', header=TRUE, sep='\t')
kable((arg.df), escape=TRUE, caption="Argument list of \'spatial_hm\'.")
```

## Mouse Organs {#mus}

This section generates an SHM plot for mouse data from the Expression Atlas.
The code components are very similar to the previous [Human Brain](#hum)
example. For brevity, the corresponding text explaining the code has
been reduced to a minimum. 

### Gene Expression Data

The chosen mouse RNA-Seq data compares tissue level gene expression across 
mammalian species [@Merkin2012-ak]. The following searches the Expression 
Atlas for expression data from _'heart'_ and _'Mus musculus'_.

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
all.mus <- searchAtlasExperiments(properties="heart", species="Mus musculus")
```

Among the many matching entries, accession 'E-MTAB-2801' will be downloaded.  

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
all.mus[7, ]
rse.mus <- getAtlasData('E-MTAB-2801')[[1]][[1]]
```

The design of the downloaded RNA-Seq experiment is described in the `colData` slot of 
`rse.mus`. The following returns only its first three rows.

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
colData(rse.mus)[1:3, ]
```

### aSVG Image  

The following example shows how to download from the [EBI SVG
repository](#svg_repo) an aSVG image that matches the tissues and species
assayed in the gene expression data set downloaded in the previous subsection.
As before the image is saved to a directory named `~/test`.

```{r eval=FALSE, echo=TRUE, warnings=FALSE }
if (!dir.exists('~/test')) dir.create('~/test')
feature.df <- return_feature(feature=c('heart', 'kidney'), species=c('Mus musculus'), keywords.any=TRUE, return.all=FALSE, dir='~/test', remote=TRUE, match.only=FALSE)
```

To build this vignettes according to the R/Bioconductor package requirements, the
following code section uses the aSVG file instance included in the
`spatialHeatmap` package rather than the downloaded instance from the previous
example. 

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
feature.df <- return_feature(feature=c('heart', 'kidney'), species=NULL, keywords.any=TRUE, return.all=FALSE, dir=svg.dir, remote=FALSE, match.only=FALSE) 
```

Return the names of the matching aSVG files.

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
unique(feature.df$SVG)
```

The following first selects `mus_musculus.male.svg` as target aSVG, then returns the 
first three rows of the resulting `feature.df`, and finally prints the unique set of all
aSVG features.   

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
feature.df <- subset(feature.df, SVG=='mus_musculus.male.svg')
feature.df[1:3, ]
unique(feature.df[, 1])
```

Obtain path of target aSVG on user system.   

```{r eval=TRUE, echo=TRUE, warnings=FALSE}
svg.mus <- system.file("extdata/shinyApp/example", "mus_musculus.male.svg", package="spatialHeatmap")
```

### Experimental Design

Import of custom target file defining simplified sample labels and experimental
design. The following imports a sample target file that is included in this package.
To inspect its content, the first three rows of the target file are printed to the 
screen.

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
mus.tar <- system.file('extdata/shinyApp/example/target_mouse.txt', package='spatialHeatmap')
target.mus <- read.table(mus.tar, header=TRUE, row.names=1, sep='\t')
target.mus[1:3, ]
unique(target.mus[, 3])
```

Load custom target data into `colData` slot.  

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
colData(rse.mus) <- DataFrame(target.mus)
```

### Preprocess Assay Data

The raw RNA-Seq count are preprocessed with the following steps: (1)
normalization, (2) aggregation of replicates, and (3) filtering of reliable
expression data. The details of these steps are explained in the previous
sub-section using data from human.

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
se.nor.mus <- norm_data(data=rse.mus, norm.fun='ESF', data.trans='log2') # Normalization
se.aggr.mus <- aggr_rep(data=se.nor.mus, sam.factor='organism_part', con.factor='strain', aggr='mean') # Aggregation of replicates
se.fil.mus <- filter_data(data=se.aggr.mus, sam.factor='organism_part', con.factor='strain', pOA=c(0.01, 5), CV=c(0.6, 100), dir=NULL) # Filtering of genes with low counts and variance 
```

### SHM: Transparency

The pre-processed expression data for gene 'ENSMUSG00000000263' is plotted in form
of an SHM. In this case the plot includes expression data for 8 tissues across 3 
mouse strains. 

```{r musshm, eval=TRUE, echo=TRUE, warnings=FALSE, fig.wide=TRUE, fig.cap=("SHM of mouse organs. This is a multiple-layer image where the polygon of the 'skeletal muscle' is set transparent to expose 'lung' and 'heart'."), out.width="100%" }
spatial_hm(svg.path=svg.mus, data=se.fil.mus, ID=c('ENSMUSG00000000263'), height=0.5, legend.r=1.1, sub.title.size=9, ncol=3, tis.trans=c('skeletal muscle'), legend.nrow=4, line.size=0.2, line.color='grey70')
```

The SHM plots in Figures \@ref(fig:musshm) and \@ref(fig:musshm1) demonstrate
the usage of the transparency feature via the `tis.trans` parameter. The
corresponding mouse organ aSVG image includes overlapping tissue layers. In
this case the skelectal muscle layer partially overlaps with lung and heart
tissues. To view lung and heart in Figure \@ref(fig:musshm), the skelectal
muscle tissue is set transparent with `tis.trans=c('skeletal muscle')`. To view
in the same aSVG the skeletal muscle tissue instead, `tis.trans` is assigned
`NULL` for generating the SHM plot of Figure \@ref(fig:musshm1).

To fine control the visual effects in feature rich aSVGs, the `line.size` and
`line.color` parameters are useful. This way one can adjust the thickness and 
color of complex polygon structures.


```{r musshm1, eval=TRUE, echo=TRUE, warnings=FALSE, fig.wide=TRUE, fig.cap=("SHM of mouse organs. This is a multiple-layer image where the view onto 'lung' and 'heart' is obstructed by displaying the 'skeletal muscle' tissue."), out.width="100%" }
spatial_hm(svg.path=svg.mus, data=se.fil.mus, ID=c('ENSMUSG00000000263'), height=0.5, legend.r=1.1, sub.title.size=9, ncol=3, tis.trans=NULL, legend.ncol=2, line.size=0.2, line.color='grey70')
```

## Chicken Organs {#chk}

This section generates an SHM plot for chicken data from the Expression Atlas.
The code components are very similar to the [Human Brain](#hum) example. For
brevity, the corresponding text explaining the code has been reduced to a
minimum. 

### Gene Expression Data

The chosen chicken RNA-Seq experiment compares the developmental changes across 
nine time points of seven organs [@Cardoso-Moreira2019-yq].


The following searches the Expression Atlas for expression data from _'heart'_
and _'gallus'_.

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
all.chk <- searchAtlasExperiments(properties="heart", species="gallus")
```

Among the matching entries, accession 'E-MTAB-6769' will be downloaded.  

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
all.chk[3, ]
rse.chk <- getAtlasData('E-MTAB-6769')[[1]][[1]]
```

The design of the downloaded RNA-Seq experiment is described in the `colData`
slot of `rse.chk`. The following returns only its first three rows.

```{r eval=TRUE, echo=TRUE, warnings=FALSE } 
colData(rse.chk)[1:3, ]
```

### aSVG Image  

The following example shows how to download from the [EBI SVG
repository](#svg_repo) an aSVG image that matches the tissues and species
assayed in the gene expression data set downloaded in the previous subsection.
As before the image is saved to a directory named `~/test`.

```{r eval=FALSE, echo=TRUE, warnings=FALSE }
# Make an empty directory "~/test" if not exist.
if (!dir.exists('~/test')) dir.create('~/test')
# Query aSVGs.
feature.df <- return_feature(feature=c('heart', 'kidney'), species=c('gallus'), keywords.any=TRUE, return.all=FALSE, dir='~/test', remote=TRUE, match.only=FALSE)
```

To build this vignettes according to the R/Bioconductor package requirements, the
following code section uses the aSVG file instance included in the
`spatialHeatmap` package rather than the downloaded instance from the previous
example. 

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
feature.df <- return_feature(feature=c('heart', 'kidney'), species=c('gallus'), keywords.any=TRUE, return.all=FALSE, dir=svg.dir, remote=FALSE, match.only=FALSE)
feature.df
```

Obtain path of target aSVG on user system.   

```{r eval=TRUE, echo=TRUE, warnings=FALSE}
svg.chk <- system.file("extdata/shinyApp/example", "gallus_gallus.svg", package="spatialHeatmap")
```

### Experimental Design

Import of custom target file defining simplified sample labels and experimental
design. The following imports a sample target file that is included in this package.
To inspect its content, the first three rows of the target file are printed to the 
screen.

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
chk.tar <- system.file('extdata/shinyApp/example/target_chicken.txt', package='spatialHeatmap')
target.chk <- read.table(chk.tar, header=TRUE, row.names=1, sep='\t')
target.chk[1:3, ]
```

Load custom target data into `colData` slot.  

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
colData(rse.chk) <- DataFrame(target.chk)
```

All samples used for plotting SHMs.  

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
unique(colData(rse.chk)[, 'organism_part'])
```

Return conditions considered for plotting downstream SHM.  

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
unique(colData(rse.chk)[, 'age'])
```

### Preprocess Assay Data

The raw RNA-Seq count are preprocessed with the following steps: (1)
normalization, (2) aggregation of replicates, and (3) filtering of reliable
expression data. The details of these steps are explained in the above
sub-section using data from human.

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
se.nor.chk <- norm_data(data=rse.chk, norm.fun='ESF', data.trans='log2') # Normalization
se.aggr.chk <- aggr_rep(data=se.nor.chk, sam.factor='organism_part', con.factor='age', aggr='mean') # Replicate agggregation using mean 
se.fil.chk <- filter_data(data=se.aggr.chk, sam.factor='organism_part', con.factor='age', pOA=c(0.01, 5), CV=c(0.6, 100), dir=NULL) # Filtering of genes with low counts and varince
```

### SHM: Time Series

The expression profile for gene `ENSGALG00000006346` is plotted across nine time
points in four organs in form of a composite SHM with 9 panels. Their layout in
three columns is controlled with the argument setting `ncol=3`. ^[The order of the
time points in Figure 7 should be by time. Right now it is rather random.]

```{r chkshm, eval=TRUE, echo=TRUE, warnings=FALSE, fig.wide=TRUE, fig.cap=("Time course of chicken organs. The SHM shows the expression profile of a single gene across nine time points and four organs."), out.width="100%" }
spatial_hm(svg.path=svg.chk, data=se.fil.chk, ID='ENSGALG00000006346', legend.r=1.5, sub.title.size=9, ncol=3, legend.nrow=2)
```

## Arabidopsis Shoot {#shoot}

This section generates an SHM for _Arabidopsis thaliana_ with gene expression
data from the Affymetrix microarray technology. The chosen experiment used
ribosome-associated mRNAs from several cell populations of shoots and roots that were
exposed to hypoxia stress [@Mustroph2009-nu]. In this case the expression data
will be downloaded from [GEO](https://www.ncbi.nlm.nih.gov/geo/) with utilites
from the `GEOquery` package [@geo] and the preprocessing routines will be
specific to the Affymetrix technology. The remaining code components for
generating SHMs are very similar to the previous examples. For brevity, the
text in this section explains mainly the steps that are specific to this data
set. 


### Gene Expression Data

The GSE14502 data set is downloaded with the `getGEO` function from the `GEOquery` 
package. Intermediately, the expression data is stored in an `ExpressionSet` container 
and then converted to a `SummarizedExperiment` object.

```{r eval=TRUE, echo=TRUE, warnings=FALSE}
gset <- getGEO("GSE14502", GSEMatrix=TRUE, getGPL=TRUE)[[1]]
se.sh <- as(gset, "SummarizedExperiment")
```

The gene symbol identifiers are extracted from the `rowData` component and used 
as row names. Similarly, one can work with AGI identifiers by providing below `AGI` 
under `Gene.Symbol`.

```{r eval=TRUE, echo=TRUE, warnings=FALSE}
rownames(se.sh) <- make.names(rowData(se.sh)[, 'Gene.Symbol'])
```

The following returns a slice of the experimental design stored in the
`colData` slot. Both the samples and conditions are contained in the `title` column.
The samples include promoters (pGL2, pCO2, pSCR, pWOL, p35S), tissues 
and organs (root atrichoblast epidermis, root cortex meristematic zone, root 
endodermis, root vasculature, root_total and shoot_total); and the conditions 
are control and hypoxia.  

```{r eval=TRUE, echo=TRUE, warnings=FALSE}
colData(se.sh)[60:63, 1:4]
```

### aSVG Image  

In this example, the aSVG image has been regenerated in Inkscape from 
the corresponding figure in @Mustroph2009-nu. The resulting custom figure
has been included as a sample aSVG file in the `spatialHeatmap` package. Detailed 
instructions for generating custom aSVG images in Inkscape are provided in the 
[SVG tutorial](https://jianhaizhang.github.io/SVG_tutorial_file/).   

The annotations in the corresponding aSVG file located under `svg.dir` can be
queried with the `return_features` function.  

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
feature.df <- return_feature(feature=c('pGL2', 'pRBCS'), species=c('shoot'), keywords.any=TRUE, return.all=FALSE, dir=svg.dir, remote=FALSE, match.only=FALSE)
```

The unique set of the matching aSVG files can be returned as follows.   

```{r eval=TRUE, echo=TRUE, warnings=FALSE } 
unique(feature.df$SVG)
```

The aSVG file `shoot_final.svg` is chosen to generate the SHM in this section.

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
feature.df <- subset(feature.df, SVG=='shoot_final.svg')
feature.df[1:3, ]
```

Obtain full path of target aSVG on user system.   

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
svg.sh <- system.file("extdata/shinyApp/example", "shoot_final.svg", package="spatialHeatmap")
```

### Experimental Design

The following imports a sample target file that is included in this package.
To inspect its content, four selected rows of this target file are printed to the 
screen.

```{r eval=TRUE, echo=TRUE, warnings=FALSE}
sh.tar <- system.file('extdata/shinyApp/example/target_arab.txt', package='spatialHeatmap')
target.sh <- read.table(sh.tar, header=TRUE, row.names=1, sep='\t')
target.sh[60:63, ]
```

Return all samples present in target file.     

```{r eval=TRUE, echo=TRUE, warnings=FALSE}
unique(target.sh[, 'samples'])
```

Return all conditions present in target file.  

```{r eval=TRUE, echo=TRUE, warnings=FALSE}
unique(target.sh[, 'conditions'])
```

Load custom target data into `colData` slot.  

```{r eval=TRUE, echo=TRUE, warnings=FALSE}
colData(se.sh) <- DataFrame(target.sh)
```

### Preprocess Assay Data

The downloaded GSE14502 data set has already been normalized with the RMA
algorithm [@affy]. Thus, the pre-processing steps can be restricted to the
aggregation of replicates and filtering of reliably expressed genes. For the
latter, the following code will retain genes with expression values larger than
6 (log2 space) in at least 3% of all samples (pOA=c(0.03, 6)), and with a
coefficient of variance (CV) between 0.30 and 100 (CV=c(0.30, 100)).   

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
se.aggr.sh <- aggr_rep(data=se.sh, sam.factor='samples', con.factor='conditions', aggr='mean') # Replicate agggregation using mean
se.fil.arab <- filter_data(data=se.aggr.sh, sam.factor='samples', con.factor='conditions', pOA=c(0.03, 6), CV=c(0.30, 100), dir=NULL) # Filtering of genes with low intensities and variance
```

### SHM: Microarray Example

The expression profile for the HRE2 gene is plotted for control and hypoxia treatment
across six cell types (Figure \@ref(fig:shshm)).

```{r shshm, eval=TRUE, echo=TRUE, warnings=FALSE, fig.wide=TRUE, fig.cap=('SHM of Arabidopsis shoots. The expression profile of the HRE2 gene is plotted for control and hypoxia treatment across six cell types.'), out.width="100%"}
spatial_hm(svg.path=svg.sh, data=se.fil.arab, ID=c("HRE2"), height=0.6, legend.nrow=3, legend.r=1.3, legend.key.size=0.3)
```

# Matrix Heatmaps {#mhm}

SHMs are a visualization approach suitable for comparing the expression profiles
of single genes or a small number of them across cell types and conditions. To 
also support analyses across larger number of genes, `spatialHeatmap` provides 
utilities for identifying for a gene of interest nearest neighbor genes that share 
similar expression profiles. This is achieved by identifying clusters and 
network modules using hierarchical clustering and network analysis. These approaches
are described in this and the following sections, respectively.

 __Adjacency Matrix and Module Identification__^[Why this title if there are no 
 additional ones in this section. Is this an orphan leftover from somewhere else?]  

<font color='red'>[ThG-Comment: this section needs major improvements. The intent was
to identify for a target gene nearest neighbors based on some similarity metric for gene
expression profiles (e.g. correlation), and then hierarchically cluster them and visualize
the result in a heatmap. Instead you are subjecting the entire expression matrix to 
clustering/WGCNA and then plot the target gene in the context of a single
cluster/module. This is hugely inefficient compared to doing it only for the nearest
neighbors instead. Just think about what will happen if a user imports an expression 
matrix for all transcripts from human. With your approach they will not be able to 
complete this step since they will run out of memory on their system.]</font>

<a name="ds"></a>
The modules are identified by `adj_mod`. It first computes an adjacency
matrix^[You need to describe how this adjency matrix is generated and what it
represents. It also needs to mention what type of disance/correlation method is used
initially to generate the downstream matrix.] on the gene expression matrix then hierarchically clusters the
adjacency matrix by using WGCNA [@Langfelder2008-sg]^[Unclear for what you need
WGCNA here. I thought this section uses hierarchical clustering. The latter is
certainly used by WGCNA but it remains a mystery what exactly you are doing
here.] I would expect to use here only hierarchical clustering, e.g. with
flashClust. WGCNA seems more suitable for the next section.] and flashClust
[@flashClust]. The clutersing includes 4 alternative sensitivity levels
(`ds`=0, 1, 2, or 3).^[What is the meaning of the sensitivity levels, how are they 
generated and how should the user interpret them?] From 3 to 0, the sensitivity decreases and results in
less modules with larger sizes. Since the [interactive network](#inter_net)
functionality performs better on smaller modules, only `ds` of 3 and 2 are
used. There is another parameter `type` for module identification: `signed` and
`unsinged`. The former means both positive and negative adjacency between genes
are used while the latter takes the absolute values of negative adjacency^[Without
defining how adjacency is defined here readers will not be able to understand
what was done here, especially since this section is mainly about hierarchical 
clustering.].  

The function `adj_mod` returns a list containing an adjacency matrix and a data
frame of module assignment. It is domenstrated on the [Arabidopsis
Shoot](#plot_sh) data.

```{r eval=TRUE, echo=TRUE, warnings=FALSE, results=FALSE}
adj.mod <- adj_mod(data=se.fil.arab)
```   

The adjacency matrix is a measure of co-expression similarity between genes,
where larger value denotes more similarity.   

```{r eval=TRUE, echo=TRUE, warnings=FALSE}
adj.mod[['adj']][1:3, 1:3]
```

The module assignment is a data frame. The first column is `ds=2` while the second is `ds=3`. The numbers in each column are module labels with "0" meaning genes not assigned to any modules.   

```{r eval=TRUE, echo=TRUE, warnings=FALSE}
adj.mod[['mod']][1:3, ]
```

<a name="mhm1"></a>
The matrix heatmap is implemented in function `matrix_hm` with 2 modes provided: static or interactive. Figure \@ref(fig:static) is the static mode on gene `HRE2`. Setting `static=FALSE` launches the interactive mode, where users can zoom in and out by drawing a rectangle and by double clicking the heatmap, respectively.

```{r static, eval=TRUE, echo=TRUE, warnings=FALSE, fig.cap=("Matrix Heatmap. Rows are genes and columns are samples. The input gene is tagged by 2 black lines."), out.width='100%'}
matrix_hm(geneID="HRE2", data=se.fil.arab, adj.mod=adj.mod, angleCol=80, angleRow=35, cexRow=0.8, cexCol=0.8, margin=c(10, 6), static=TRUE, arg.lis1=list(offsetRow=0.1, offsetCol=0.1))
```   

In Figure \@ref(fig:static), the target gene is displayed in the gene module it belongs to, which is indicated by 2 black lines. The rows and columns are sorted by hierarchical clustering dendrograms. The expression matrix of this module is visualised without being scaled (`scale="no"`). It can be seen that the expression levels of this module is overall much higher in `hypoxia` than `control`, and therefore it could potentially be used to infer the `hypoxia` response mechanism in Arabidopsis.   


# Network Graphs {#net}

<font color='red'>[ThG-Comment: both the previous section and this section need
                   to clearly explain what is done to arrive at a given network 
                   module and what it represents. Once this is done I will edit 
                   the text.]</font>

The same target gene and module from matrix heatmap can also be displayed as a network. Similarly, the network can be dispayed in static or interactive mode.  

Setting `static=TRUE` launches the static network. In Figure \@ref(fig:inter) Nodes are genes and edges are adjacencies between genes. The thicker edge denotes higher adjacency (co-expression similarity) while larger node indicates higher gene connectivity (sum of a gene\'s adjacency with all its direct neighbours). The target gene is labeled by '_selected'.  

```{r inter, eval=TRUE, echo=TRUE, warnings=FALSE, fig.cap=("Static network. Node size denotes gene connectivity while edge thickness stands for co-expression similarity.") }
network(geneID="HRE2", data=se.fil.arab, adj.mod=adj.mod, adj.min=0.75, vertex.label.cex=1.2, vertex.cex=2, static=TRUE)
```   

<a name="inter_net"></a>
Setting `static=FALSE` launches the interactive network. There is an interactive color bar to denote gene connectivity. The color ingredients must only be separated by comma, e.g. `purple,yellow,blue`, which means gene connectivity increases from purple to yellow. If too many edges (e.g.: > 300) are displayed, the network could get stuck. So the 'Input an adjacency threshold to display the adjacency network.' option sets a threthold to filter out weak edges. If not too many edges retained (e.g.: < 300), users can check 'Yes' under 'Display or not?', then the network would be responsive smoothly. To maintain acceptable performance, users are advised to choose a stringent threshold (e.g. 0.9) initially, then decrease the value gradually. The interactive feature allows users to zoom in and out, or drag a gene around. All the gene IDs in the network module are listed in 'Select by id' in decreasing order according to gene connectivity. Same with static mode, the target gene ID is appended '_selected'.  

If gene annotation is available in `rowData` slot and provided to `ann` argument, the annotation is seen by mousing over a node. In this example, `Target.Description` in `rowData` is provided to `ann`.  

```{r eval=FALSE, echo=TRUE, warnings=FALSE}
network(geneID="HRE2", data=se.fil.arab, ann='Target.Description', adj.mod=adj.mod, static=FALSE)
```

# Shiny App {#shiny}

In additon to generating SHMs and the corresponding gene context plots from R,
`spatialHeatmap` includes a [Shiny App](https://shiny.rstudio.com/) that
provides access to the same functionalities from an intuitive-to-use web
browser interface.  Apart from being very user-friendly, this App
conveniently organizes the results of the entire visualization workflow in a
single browser window with options to adjust the parameters of the individual components
interactively. For instance, genes can be selected and replotted in the SHM
simply by clicking the corresponding rows in the expression table included in the same window. 
This representation is very efficient in guiding the interpretation of the results 
in a visual and user-friendly manner. For testing purposes, the `spatialHeatmap` 
Shiny App also includes ready-to-use sample expression data and aSVG images 
along with embedded user instructions.

## Local System 

The Shiny App of `spatialHeatmap` can be launched from an R session with the following
function call. 

```{r eval=FALSE, echo=TRUE, warnings=FALSE}
shiny_all()
```   

<font color='red'>[ThG-Comment: many menu items are not functional in the Shiny App. 
E.g.: Instructions and Acknowledgement return error messages.]</font>

The dashboard panels of the Shiny App are organized as follows:

1. Left Side Panel: menu for workflow execution and parameter selection
2. Expression Matrix: scrollable expression matrix uploaded by user
3. Spatial Heatmap: aSVG image provided by user
4. Matrix Heatmap: hierarchical clustering results for genes with similar expression profiles as target gene(s)
5. Network Graph: interactive network module generated for genes with similar expression proviles as target gene(s)

A screenshot of the Spatial Heatmap component within the Shiny App window is shown below 
(Figure \@ref(fig:shiny)).

```{r shiny, echo=FALSE, fig.wide=TRUE, fig.cap=("Screenshot of `spatialHeatmap's` Shiny App."), out.width="100%"}
include_graphics('img/shiny.png')
```  

After launching, the Shiny App displays by default one of the included data sets. 

The gene expression data and aSVG image files can be uploaded to the Shiny App
as tabular text (_e.g._ in CSV or TSV format) and SVG files, respectively. To
also allow users to upload gene expression data stored in
`SummarizedExperiment` objects, one can export them from R to a tabular file
with the `filter_data` function. In this function call the user sets the
desired directory path under `dir`. Within this directory the tabular file will 
be written to `local_mode_result/processed_data.txt` in TSV format. The
column names in the exported tabular file preserve the experimental design information from 
the `colData` slot by concatenating the corresponding sample and condition information 
separated by double underscores. An example of this format is shown in Table \@ref(tab:humtab). 

To interactively access gene- or transcript-level annotations in the plots and
tabels of the Shiny App, such as viewing functional descriptions by moving the
cursor over network nodes, the corresponding annotation column needs to be
present in the `rowData` slot and its column name assigned to the `ann`
argument. In the exported tabular file the extra annotation column is appended
to the expression matrix. ^[Check for correctness. For readability I made a lot
                            of changes in this paragraph.] 

```{r eval=FALSE, echo=TRUE, warnings=FALSE}
se.fil.arab <- filter_data(data=se.aggr.sh, ann="Target.Description", sam.factor='samples', con.factor='conditions', pOA=c(0.03, 6), CV=c(0.30, 100), dir='./')
```

## Server Deployment

As most Shiny Apps, `spatialHeatmap` can be deployed as a centralized web
service. A major advantage of a web server deployment is that the
functionalities can be accessed remotely by anyone on the internet without the
need to use R on the user system. For deployment one can use custom web
servers or cloud services, such as AWS, GCP or
[shinysapps.io](https://www.shinyapps.io/). An example web instance for testing
`spatialHeatmap` online is available
[here](https://www.plantsecretome.org/software/spatialheatmap).

# Supplement {#sup} 

To generate SHMs with custom data, proper formatting of the numeric (assay)
data and/or aSVG images is required. A tabular target file describing the
numeric data can also be provided but is optional. This section provides
additional details on these three input types.

## Numeric Data {#data_form}

The numceric data used to color the features in aSVG images can be provided as
three different object types including `vector`, `data.frame` and
`SummerizedExperiment` objects. When working with complex omics-based assay
data then the latter provides the most flexibility, and thus should be the
preferred container class for managing numeric data in `spatialHeatmap`. Both
`data.frame` and `SummarizedExperiment` can hold data from many measured items,
such as genes, across large numbers of samples and conditions. In contrast to
this, the `vector` class is only suitable for data from single items. Due to its
simplicity this less complex container is often useful for testing or when dealing with simple
data sets.

### Object Types

#### `vector`

When using numeric vectors as input to `spatial_hm`, then their name slot needs
to be populated with strings matching the feature names in the corresponding aSVG. 
To also specify conditions, their labels need to be appended to the feature names
with double underscores separators, _i.e._ 'feature__condition'. 

The following example replots the [toy example](#toy) for two spatial features 
('occipital lobe' and 'parietal lobe') and two conditions ('1' and '2'). 

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
vec <- sample(x=1:100, size=5) # Random numeric values
names(vec) <- c('occipital lobe__condition1', 'occipital lobe__condition2', 'parietal lobe__condition1', 'parietal lobe__condition2', 'notMapped') # Assign unique names to random values
vec
```

With this configuration the resulting plot contains two spatial heatmap plots for
the human brain, one for 'condition 1' and another one for 'contition 2'. Since the
`spatial_hm` function call in this code block is not evaluated, the actual SHM is 
not shown in this vignette.

```{r vecshm, eval=FALSE, echo=TRUE, warnings=FALSE, fig.wide=FALSE, fig.cap=c('SHMs on a vector. \'occipital lobe\' and \'parietal lobe\' are 2 aSVG features and \'condition1\' and \'condition2\' are conditions.')}
spatial_hm(svg.path=svg.hum, data=vec, ID='toy', ncol=1, legend.r=1.2, sub.title.size=14)
```

#### `data.frame`  

In the case of data frame, numeric values are measured from different samples. Similarly, if one or more conditions are provided, the column names should be in the form of 'sample__condition'. If no conditions are provided, all the samples are assumed to have same condition.   

Take the same samples and conditions in the `vector` case as example.  

Make a numeric data frame of 20 rows and 5 columns. Name columns with the value names (each is unique) from above vector and rows with 20 genes (gene1, gene2, ..., gene20).  

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
# Make a numeric data frame.
df.test <- data.frame(matrix(sample(x=1:1000, size=100), nrow=20))
# Name the columns.
colnames(df.test) <- names(vec)
# Name the rows.
rownames(df.test) <- paste0('gene', 1:20)
# A slice of the data frame.
df.test[1:3, ]
```

In the downstream [interactive network](#inter_net), if users want to have a gene annotation by mousing over a node, a column of gene annotation can be appended to the data frame. For example, the 20 genes are annotated as ann1, ann2, ..., ann20.   

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
df.test$ann <- paste0('ann', 1:20)
df.test[1:3, ]
```

The pre-processing steps are optional and thus are skipped. Next plot SHMs on `gene1`.   

```{r dfshm, eval=FALSE, echo=TRUE, warnings=FALSE, fig.wide=FALSE, fig.cap=c('SHMs on a data frame. \'occipital lobe\' and \'parietal lobe\' are 2 aSVG features and \'condition1\' and \'condition2\' are conditions.')}
spatial_hm(svg.path=svg.hum, data=df.test, ID=c('gene1'), ncol=1, legend.r=1.2, sub.title.size=14)
```

#### `SummarizedExperiment` 

In the following, the same samples and conditions in the above data frame are taken as example.  

Formatting data of `SummarizedExperiment` (SE, @SummarizedExperiment) is essentially to make a targets file (a data frame of column metadata). The targets file usually has at least 2 columns that specifies sample and condition replicates respectively, and should be added to the `colData` slot. The data matrix should have assayed items (*e.g.* genes) and sample/conditions in rows and columns respectively, and must be in the `assay` slot. The `rowData` slot can store a data frame of annotaions corresponding to rows in `assay` slot, but is not required.  

To plot spaital heatmap successfully, the targets file should meet the following requirements.  

1. It is a `data frame` and usually has at least one column of samples and one column of conditions. The rows correspond with columns in `assay` slot. If the condition column is not defined, the samples are assumped under same condition.
 
2. The sample column specifies sample replicates. It is crucial that replicate names of the same sample must be identical. Otherwise, they are treated as different samples. E.g. 
`occipital lobe`, `occipital lobe` are the same sample while `occipital lobe1`, `occipital lobe2` are different samples. 

3. The sample identifiers of interest must be identical with features of interest in aSVG respectively. It means even a dot, undescore, space, *etc* can make a difference and lead to target features not colored in SHMs. Since double underscore (_\_) is a reserved separator in *spatialHeatmap*, it cannot be used in sample or condition identifiers.  

4. The condition column has the same requirement with the sample column. E.g. `condition1`, `condition1` is same conditoin while `condition1A`, `condition1B` is treated as different conditions.   


In the following example, `occipital lobe` has 2 conditions `condition1` and `condition2`, and each condition has 2 replicates, so there are 4 assays for `occipital lobe`. The same applies to `parietal lobe`. Based on this experiment design, the corresponding targets file is made, where a row is an assay.   

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
# Two samples.
sample <- c(rep('occipital lobe', 4), rep('parietal lobe', 4))
# Two conditions.
condition <- rep(c('condition1', 'condition1', 'condition2', 'condition2'), 2)
# Targets file.
target.test <- data.frame(sample=sample, condition=condition, row.names=paste0('assay', 1:8))
target.test
```

Make a random numeric data frame of 8 columns and 20 rows. Each column is an assay and each row is a gene\'s expression profile. Columns must correspond with rows in targets file, so column names are assigned assay1-8.  

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
# Make a numeric data frame.
df.se <- data.frame(matrix(sample(x=1:1000, size=160), nrow=20))
# Name the rows.
rownames(df.se) <- paste0('gene', 1:20)
# Replace the default column names. 
colnames(df.se) <- row.names(target.test)
# A slice of the data frame.
df.se[1:3, ]
se <- SummarizedExperiment(assays=df.se, colData=target.test)
se
```

Similarly, in the downstream [interactive network](#inter_net), if users want to have a gene annotation by mousing over a node, a data frame of gene annotation can be added to `rowData` slot, *i.e.* the `ann` column in `df.test`.  

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
rowData(se) <- df.test['ann']
```

In this simple example, the normalization and filtering process is left out, but replicates should be aggregated. In function `aggr_rep`, the `sample` and `condition` columns in targets file are concatenated with double underscore to form 'sample__condition' replicates for aggregating.  

```{r eval=TRUE, echo=TRUE, warnings=FALSE }
se.aggr <- aggr_rep(data=se, sam.factor='sample', con.factor='condition', aggr='mean')
assay(se.aggr)[1:3, ]
```

Plot SHMs on `gene1`.     

```{r seshm, eval=FALSE, echo=TRUE, warnings=FALSE, fig.wide=FALSE, fig.cap=c('SHMs on a SummarizedExperiment. \'occipital lobe\' and \'parietal lobe\' are 2 aSVG features and \'condition1\' and \'condition2\' are conditions.')}
spatial_hm(svg.path=svg.hum, data=se.aggr, ID=c('gene1'), ncol=1, legend.r=1.2, sub.title.size=14)
```

## aSVG File

### aSVG repository {#svg_repo}

The aSVG repository is from [EBI Gene Expression Group](https://github.com/ebi-gene-expression-group/anatomogram/tree/master/src/svg), where the requirements on aSVG format are included. It contains aSVGs across different species and can be downloaded with funtion `return_feature` directly. If users cannot find a target aSVG in this repository, there is a step-by-step [SVG tutorial](https://jianhaizhang.github.io/SVG_tutorial_file/) to create custom aSVG images, which is developed by this project.    


### Update aSVG features {#update}

To change existing feature identifiers in aSVG, the function `update_feature` should be used. For testing purpose, an empty folder `~/test1` is created and a copy of the aSVG `homo_sapiens.brain.svg` packaged in *spatialHeatmap* is saved in there.  

<!-- To avoid creating '~/test1' in users' computer, the following code chunks are not evaluated when building this vignette. -->

```{r eval=FALSE, echo=TRUE, warnings=FALSE }
# Make an empty directory.
if (!dir.exists('~/test1')) dir.create('~/test1')
# Copy the "homo_sapiens.brain.svg" aSVG.
svg.hum <- system.file("extdata/shinyApp/example", 'homo_sapiens.brain.svg', package="spatialHeatmap")
file.copy(from=svg.hum, to='~/test1', overwrite=FALSE)
```

Use feature and species keywords to query the aSVG and return existing features, which is a data frame. 

```{r eval=FALSE, echo=TRUE, warnings=FALSE }
feature.df <- return_feature(feature=c('frontal cortex'), species=c('homo sapiens', 'brain'), dir='~/test1', remote=FALSE, keywords.any=FALSE)
feature.df
``` 

Make a vector of new feature identifiers corresponding to every returned feature, *e.g.* replacing spaces with dots. This vector must be added to the first column of the feature data frame, since that is where `update_feature` looks for new features. Then features are updated with `update_feature`.    

```{r eval=FALSE, echo=TRUE, warnings=FALSE } 
# A vector of new features.
f.new <- c('frontal.cortex', 'prefrontal.cortex')

# New features added to the first column of feature data frame.
feature.df.new <- cbind(featureNew=f.new, feature.df)
feature.df.new

# Update the features.
update_feature(feature=feature.df.new, dir='~/test1')
```

## Target File

...^[Provide basics here.]

<br/>


```{r eval=TRUE, echo=TRUE}

# Version Informaion
sessionInfo()
```

# Funding

This project has been funded by NSF awards: [PGRP-1546879](https://www.nsf.gov/awardsearch/showAward?AWD_ID=1546879&HistoricalAwards=false), [PGRP-1810468](https://www.nsf.gov/awardsearch/showAward?AWD_ID=1810468), [PGRP-1936492](https://www.nsf.gov/awardsearch/showAward?AWD_ID=1936492&HistoricalAwards=false).

# References






















