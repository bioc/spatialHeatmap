---
title: "spatialHeatmap Vignette"
author: "Jianhai Zhang, PhD student at Genetics, Genomics and Bioinformatics, University of California, Riverside (<jzhan067@ucr.edu>; <zhang.jianhai@hotmail.com>) <p/> PI: Dr. Thomas Girke, professor at Department of Botany and Plant Sciences, University of California, Riverside (<thomas.girke@ucr.edu>)"
date: "Last update: `r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: true
    toc_float:
        collapsed: true
        smooth_scroll: true
    toc_depth: 3
    fig_caption: yes
    code_folding: show
    number_sections: true
    self_contained: true
fontsize: 14pt
bibliography: bibtex.bib
package: spatialHeatmap
vignette: |
  %\VignetteIndexEntry{spatialHeatmap Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

  Maintainer: Jianhai Zhang (<jzhan067@ucr.edu>; <zhang.jianhai@hotmail.com>)

<style type="text/css">
.main-container { max-width: 1800px; margin-left: 5px; margin-right: auto; }
</style>

<style>body { text-align: justify }</style>

```{r setup0, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}

  library(knitr); opts_chunk$set(message=FALSE, warning=FALSE)

```

# Introduction 

This R package spatialHeatmap is designed to intuitively visualise gene expression data on images where the data come from and promote hypothesis generation. Examples include but not limit to RNA-seq, microarray, qPCR, subcellular localisation of proteins, etc., regardless of species. 

The core feature "Spatial Heatmap" is to map expression profile of a target gene under different conditions to different cells/tissues/organs (samples) on an associated SVG image, where different samples are predefined. After mapping, the expression profile is represented as different colours across samples in the image, which are called spatial heatmaps. The requirements on how to configure an SVG image with a data matrix is provided [below](#svg_mat). Not all samples in the expression matrix need to be defined in the SVG image and only those defined will be mapped, vice versa. This feature allows to input multiple genes. If so, the spatial heatmaps of different genes are generated sequentially on the same page, and there is also an option to display these spatial heatmaps by genes or by conditions, which makes it flexible for users to compare expression profiles of the same gene across conditions or different genes across the same condition.  

In addition, the accessory features of "Matrix Heatmap" and "Network" display the target gene in the context of corresponding gene module, which make this package more versatile. All the utilities implemented in this R package are also combined as a web-browser based Shiny app [@shiny; @shinydashboard]. It can be used locally or [online](https://tgirke.shinyapps.io/spatialHeatmap/) on the Shiny server. 

The application of this package is not limited to gene expression data. It can be used as long as a data matrix and an associated SVG image are provided. Other exmaples include population data collected in different years across different cities, health data of an individual under different conditions, ect. In the following, the vignette is given with a gene expression matrix and an associated root tissue image in SVG format as an example. Usage on other cases is in the same way. This vignette describes the R functions and instruction on how to use the web-browser based Shiny app.  

For a quick test, users can use the example code below or the [online](https://tgirke.shinyapps.io/spatialHeatmap/) Shiny app. On the online app, users can either select the pre-configured examples from the left menu or download the example data matrix and SVG image in the insturction page.

# Installation

Start R (version "3.5") and run: 

```{r, eval=FALSE, echo=TRUE, warnings=FALSE} 

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("spatialHeatmap")

```

# Functionality and Corresponding R Functions

Load the required packages.

```{r, eval=TRUE, echo=TRUE, warnings=FALSE}

 library(spatialHeatmap); library(data.table); library(SummarizedExperiment); library(XML); library(igraph); library(ExpressionAtlas); library(genefilter); library(DESeq2)

```   

<a name="svg_mat"></a>
## Format the Data Matrix

The gene expression matrix should be normalised and filtered before downstream processing. Many R packages provide normalisation methods such as edgeR [@edgeR], DESeq2 [@DESeq2], affy [@affy], gcrma [@gcrma], etc. Since the normalisation method is chosen based on the data type and downstream analysis, this vignette does not cover the normalisation process. The expression matrix used below ([Table 1](#table), @Geng2013-ek) is Affymetrix data normalised by "gcrma", which is downloaded at [GEO](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE46205). The function `filter.data` [@SummarizedExperiment; @data.table; @utils] has two filter arguments `pOA` and `CV`, corresponding to `pOverA` and `cv` in the package "genefilter" [@Gentleman2018-xj], respectively.   

<a name="name_format"></a>
In the gene expression matrix, the row and column names should be gene IDs and sample/conditions respectively. The sample/condition names MUST be fomatted this way: a sample name is followed by double underscore then the condition, such as "epidermis__140mM_1h" in [Table 1](#table), where "epidermis" is the sample and "140mM_1h" is the condition. In the column names of sample/condition, only letters, digits, single underscore, single space, or dots are allowed. Not all samples in the matrix necessarily need to be present in the SVG image, vice versa. Only samples present in the SVG image are recognised and coloured.

The expression matrix is stored as an "SummarizedExperiment" object. Metadata of genes and sample/conditions can be optionally added. Refer to the R package "SummarizedExperiment" for more details [@SummarizedExperiment].

The example of gene expression matrix and how to use this function is shown [below](#filter) [@Geng2013-ek; @knitr; @kableExtra; @data.table]. The complete matrix (root_expr_row_gen.txt) is accessible in this package as shown below or can be downloaded from the web-browser based Shiny app.  

<a name="filter"></a>
```{r, filter, eval=TRUE, echo=TRUE, warnings=FALSE}

  # Creat the "SummarizedExperiment" class.
  ## The expression matrix, where the row and column names should be gene IDs and sample/conditions respectively. This data matrix is truncated from a GEO dataset (https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE46205), which is already normalised.
  data.path <- system.file("extdata/example", "root_expr_row_gen.txt", package = "spatialHeatmap")
  expr <- fread(data.path, sep='\t', header=TRUE, fill=TRUE)
  col.na <- colnames(expr)[-ncol(expr)]; row.na <- as.data.frame(expr[, 1])[, 1]
  expr <- as.matrix(as.data.frame(expr, stringsAsFactors=FALSE)[, -1])
  rownames(expr) <- row.na; colnames(expr) <- col.na
  con.path <- system.file("extdata/example", "root_con.txt", package = "spatialHeatmap") 
  ## Condition is a single column data frame.
  con <- read.table(con.path, header=TRUE, row.names=NULL, sep='\t', stringsAsFactors=FALSE)
  ann.path <- system.file("extdata/example", "root_ann.txt", package = "spatialHeatmap")
  ## Gene annotation is a single column data frame.
  ann <- read.table(ann.path, header=TRUE, row.names=1, sep='\t', stringsAsFactors=FALSE)
  ## The expression matrix, gene annotation, and condition are stored in a "SummarizedExperiment" object. Gene annotation and condition are optional.
  expr <- SummarizedExperiment(assays=list(expr=expr), rowData=ann, colData=con)

  # Filter genes. In "pOA", genes with expression value A >= 1 in at least p=0.03 (3%) of all samples are retained; in "CV", genes with coefficient of variance (cv) between 0.1 and 10000 are retained, where the upper limit is set to very high (10000) so as to keep all genes with cv over 0.1. 
  exp <- filter.data(data=expr, pOA=c(1, 0.03), CV=c(0.1, 10000), dir=NULL)

  # Get the filtered matrix. "filter.data" returns a "SummarizedExperiment" object.
  df <- assay(exp)

```   

<a name="table"></a>
```{r, table, eval=TRUE, echo=FALSE, warnings=FALSE}

  kable(df[1:3, 1:4], caption='Table 1. Gene expression matrix. Rows and columns are genes and sample/conditions respectively.')

``` 

## Spatial Heatmap

### How does it work?

This is the core functionality of this package and is implemented by the function `spatial.hm` [@SummarizedExperiment; @grImport; @rsvg; @ggplot2; @gridExtra; @XML; @grid; @Cairo; @Gentleman2018-xj]. It maps expression profiles of target genes in the data matrix onto the associated SVG image ([Figure 1](#root_R), @Mustroph2009-nu) and displays as spatial heatmaps ([Figure 2](#shm_R)). The SVG image (root_cross_final.svg) is accessible in this package as shown below or can be downloaded from the web-browser based Shiny app.  

In Figure 1, the colours are only used to distinguish different tissues, while in Figure 2 user defined tissue regions are coloured by the expression profile of a target gene under different contidions. For example, in [Table 1](#table) the expression value of gene "PSAC" in "epidermis" under the condition "140mM_1h" is "2.457910", after mapping the "epidermis" is coloured "dark yellow", corresponsing to "2.457910" in the colour scale.   

<a name="root_R"></a>
```{r root_R, echo=FALSE, dev='svg', fig.align="center", fig.cap=("Figure 1. Original root. Tissues are labelled by different colours for easy identification."), out.width="60%"}

include_graphics('../inst/extdata/example/root_cross_final.svg')

```

<a name="shm_R"></a>
```{r, shm, eval=TRUE, echo=TRUE, warnings=FALSE, fig.align="center", fig.cap=('Figure 2. Spatial Heatmaps of the target gene \"PSAC\". User defined tissue regions are coloured by the expression profile of the target gene.')}

  # Path of the original svg image.
  svg.path <- system.file("extdata/example", "root_cross_final.svg", package = "spatialHeatmap")
  # Mapping of the target gene "PSAC" to the SVG image. Multiple target genes can be mapped at the same time. Here only one is mapped. 
spatial.hm(svg=svg.path, data=exp, pOA=c(0, 0), CV=c(0, 10000), ID="PSAC", col.com=c("yellow", "blue", "purple"), width=1, height=1, sub.title.size=9.5, layout="gene", ncol=3)

```   

### Format the SVG image

The SVG image is an XML file as shown below. To use this spatialHeatmap package, it must be formatted in the following way:  

1. If a tissue contains multiple shapes (e.g. tissue1), all the shapes must be combined as a group. The group "id" is the tissue name and must be exactly the same with that from the data matrix. Otherwise, this tissue group will not be coloured in the spatial heatmaps. However, there is no need to change path ids in this group.

2. If a tissue only has one shape (e.g. tissue2), it does not need to be formatted as a group, but its "id" must be exactly the same with that from the data matrix. Otherwise, this tissue will not be coloured in the spatial heatmaps.  

3. A group should not include another group, which means all elements in a group should be single paths.  

4. If a multiple-shape tissue is not present in the data matrix, and therefore not expected to be coloured, there is no need to group its shapes or change their ids.

5. All the tissues (groups or single paths) must be placed in another large group (e.g. large) as a whole, and this large group must be the last element in the SVG/XML file.

The SVG image can be formatted with [Inkscape](https://inkscape.org/). Refer to the step-by-step [SVG tutorial](https://jianhaizhang.github.io/SVG_tutorial_file/) for details. [Figure 3](#svg_root) is the formatted root SVG image opened in Inkscape. The first group (id="g341") is not present in the data matrix and has a random id. The other groups such as "cortex" have multiple shapes and will be coloured in the spatial heatmaps, since they are present in the data matrix ([Table 1](#table)). Below is a simple example of formatted SVG/XML file viewed in a text editor.

```{r svg_format, eval=FALSE, echo=TRUE }

<svg ...>

  <metadata ...>
  ...
  </metadata>

  <defs .../>
  <sodipodi:namedview .../>
  
  <g id="large" ...>
    <g id="tissue1" ...>
      <path .../>
      <path .../>
      ...
    </g>
    <path id="tissue2" .../>
    ...
  </g>

</svg>

```

<a name="svg_root"></a>
```{r svg_root, echo=FALSE, fig.align="center", fig.cap=("Figure 3: Root SVG image formatted in Inkscape. The first group (id=\"g341\") are not present in the data matrix and has a random id while all other groups have ids of exactly the same tissue names in the data matrix (Table 1)."), out.width="100%"}

include_graphics('img/svg_format.png')

```
### SVG templates

To make it easy for users, a [repository](https://github.com/jianhaizhang/SVG_tutorial_file/tree/master/anatomogram/src/svg/svg_trans) of SVG templates across different species is created. This repository is modified from [EBI Gene Expression Group](https://github.com/ebi-gene-expression-group/anatomogram/tree/master/src/svg), since the SVG images from EBI cannot be directly used in this package because of the format. To use this repository, users should download an SVG template of interest and configure it with a gene expression matrix as stated above. Then input the configured SVG and expression data to `spatial.hm`. More SVG templates will be added to this repository in the future. If users cannot find an SVG template of interest in this repository, they can follow the step-by-step [SVG tutorial](https://jianhaizhang.github.io/SVG_tutorial_file/) to create their custom SVG images.

The [Expression Atlas-EMBL-EBI](https://www.ebi.ac.uk/gxa/home) is a rich resource of gene expression data, which includes many conditions and species. Below is an example of how to plot the EBI expression data on the SVG template.

**Download SVG template and find tissue names:** download "homo_sapiens.brain.svg" from the SVG repository (mouse over the image and right click, then select “Save image as…”) and open it in [Inkscape](https://inkscape.org/), which should be pre-installed. In the Inkscape, as shown in Figure 3 find the "Edit" tab at the top left corner then click "XML Editor...". In the "XML Editor" panel, click the small black triangle at the bottom, then all the tissue names (id) are shown. These tissue names must be exactly the same with that in the expression matrix. Otherwise, the tissues would not be coloured in the spatial heatmaps.

<p/><center><img src="img/edit.png" hspace=10><img src="img/xml.png"></center> <p/>
<p/><center><img src="img/xml_panel.png" hspace=10><img src="img/xml_id.png"></center> <p/>
<figcaption>Figure 3 Snapshots of finding tissue names in Inkscape.</figcaption>  

<br/>Format the expression matrix and plot the spatial heatmaps:

```{r ebi, eval=TRUE, echo=TRUE, warnings=FALSE, fig.align="center", fig.cap=("Figure 4 Example of plotting EBI data on the SVG template. Cerebellum and frontal cortex are coloured, since they are the only 2 common tissues between the SVG and the expression matrix."), out.width="100%" }

# Search for human samples related to brain.
all.res <- searchAtlasExperiments(properties="brain", species="Homo sapiens")
# Select "E-GEOD-67196", which is RNA-seq data of cerebellum and frontal cortex in brain.
sl <- getAtlasData('E-GEOD-67196')[[1]][[1]]
# Raw count matrix.
df.exp <- assay(sl); df.exp[1:3, 1:5]
# Tissue/condition metadata.
df.con <- as.data.frame(colData(sl)); df.con[1:3, ]

# The matching tissues in the SVG template are "cerebellum" and "frontal_cortex" while in the expression data are "cerebellum" and "frontal cortex". The tissue names must be exactly same between the SVG and the expression matrix, so change "frontal cortex" to "frontal_cortex".
df.con$organism_part <- sub(' ', '_', df.con$organism_part)
# Use abbreviations of the conditions ("individual", "disease", "genotype").
df.con$individual <- sub('individual', 'indi', df.con$individual)
df.con$individual <- sub('Individual ', 'indi', df.con$individual)
df.con$disease <- sub('amyotrophic lateral sclerosis', 'ALS', df.con$disease)
df.con$genotype <- sub('presence of a C9orf72 repeat expansion', 'pre.C9orf72', df.con$genotype)
df.con$genotype <- sub('absence of a C9orf72 repeat expansion', 'ab.C9orf72', df.con$genotype)
df.con$genotype <- sub('not applicable', 'NA', df.con$genotype)

# The condition can be "individual", "disease", "genotype", or combinations of them. If use combined conditions, just paste the selected contitions together. 
con1 <- paste0(df.con$organism_part, '__', df.con$genotype); con1[1:4] # Single condition of "genotype".
con2 <- paste0(df.con$organism_part, '__', df.con$individual, '.', df.con$genotype); con2[1:4] # Combined conditions of "individual" and "genotype".
# Use "individual" and "genotype" as the condition.
colnames(df.exp) <- con2

# Normalise the raw counts.
se <- SummarizedExperiment(assays=list(expr=df.exp), rowData=rownames(df.exp), colData=con2)
dds <- DESeqDataSet(se, design=~1); dds <- estimateSizeFactors(dds)
# Use log2 unit.
log.df <- log2(counts(dds, normalized=TRUE)+1)
# Summary of the expression matrix.
quantile(log.df, probs=seq(0, 1, 0.25))

# Filter the expression matrix.
ffun <- filterfun(pOverA(1/ncol(log.df), 5), cv(0.6, 1000))
filtered <- genefilter(log.df, ffun); log.df <- log.df[filtered, ]; dim(log.df)

# Subset the columns to make a toy example.
log.df <- log.df[, c(1:2, 17:18, 37:38)]; con2 <- con2[c(1:2, 17:18, 37:38)]; log.df[1:3, ]
# Store the filtered expression matrix as a "SummarizedExperiment" object.
exp.ebi <- SummarizedExperiment(assays=list(expr=log.df), rowData=rownames(log.df), colData=con2)
# Set "cerebral_cortex" as transparent, since it covers "frontal_cortex". Pass the path of downloaded SVG image to the argument "svg".
spatial.hm(svg='img/homo_sapiens.brain.svg', data=exp.ebi, pOA=c(0, 0), CV=c(0, 10000), ID=rownames(log.df)[6], col.com=c("yellow", "blue", "purple"), width=1, height=0.5, sub.title.size=7, layout="gene", ncol=3, tis.trans='cerebral_cortex')

```


## Adjacency matrix and module identification
<a name="ds"></a>

The `matrix.heatmap` [@SummarizedExperiment; @ggdendro; @ggplot2; @plotly; @stats; @gplots; @reshape2] and `network` [@SummarizedExperiment; @igraph; @graphics; @shiny; @shinydashboard; @visNetwork] function are used to supplement the core feature of spatial heatmap, which are designed to display the target gene in the context of corresponding gene network module. The function `adj.mod` is designed to compute adjacency matrix and identify modules. The modules are identified using WGCNA [@Langfelder2008-sg] and flashClust [@flashClust] at two alternative sensitivity levels (3, 2). From 3 to 2, the sensitivity decreases and results in less modules with larger sizes. There are two additional options for module identification: signed and unsinged. The "signed" means both positive and negative adjacency between genes are used while the "unsigned" takes the absolute values of negative adjacency [@Langfelder2008-sg].

```{r, eval=TRUE, echo=TRUE, warnings=FALSE}

  adj_mod <- adj.mod(data=exp, type="signed", minSize=15, dir=NULL)

```   
## Matrix Heatmap

<a name="mhm1"></a>
The function `matrix.heatmap` displays the target gene in the context of corresponding gene module as a [matrix heatmap](#mhm_R), where the rows and columns are sorted by hierarchical clustering dendrograms and the target gene is tagged by 2 black lines [@ggdendro; @plotly]. The matrix heatmap has 2 modes: static or interactive. If interactive, users can zoom in and out by drawing a rectangle and by double clicking the heatmap, respectively. Users can scale the expression matrix by gene or sample.

<a name="mhm_R"></a>
```{r, eval=TRUE, echo=TRUE, warnings=FALSE, fig.height=5, fig.width=5, fig.cap=("Figure 5. Matrix Heatmap. Rows are genes and columns are samples. The input gene is tagged by 2 black lines."), out.width='100%'}

  # Static mode. For interactive mode, set "static=FALSE"
  matrix.heatmap(geneID="PSAC", data=exp, adj.mod=adj_mod, ds="2", scale="row", static=TRUE, arg.lis1=list(cexRow=0.4, cexCol=0.4, offsetRow=0.1, offsetCol=0.1))

```   

## Network

<a name="net1"></a>
The function `network` returns a [network graph](#net_R) to display the target gene in the context of the corresponding gene module, where nodes are genes and edges are adjacencies between genes. The gene module is the same with that in `matrix.heatmap`. The network can be dispayed in static or interactive mode. The thicker edge denotes higher adjacency (coexpression similarity) between genes while larger node indicates higher gene connectivity (sum of a gene's adjacency with all its direct neighbours). In the interactive mode, there is an interactive colour bar to denote gene connectivity. The colour ingredients must only be separated by comma, e.g. "yellow,black,purple", which means gene connectivity increases from yellow to purple. If too many edges (e.g.: > 300) are displayed, the network could get stuck. So the "Input an adjacency threshold to display the adjacency network." option sets a threthold to filter out weak edges and all remaining edges are displayed. If not too many (e.g.: < 300), users can check "Yes" under "Display or not?", then the network will be displayed and would be responsive smoothly. To maintain acceptable performance, users are advised to choose a stringent threshold (e.g. 0.9) initially, then decrease the value gradually. The interactive feature allows users to zoom in and out, or drag a gene around. All the gene IDs in the network module are listed in "Select by id" in decreasing order according to gene connectivity. The selected gene ID is appended "_selected" as a label. By clicking an ID in this list, users can identify the corresponding gene in the network. If the input contains gene annotation, then the annotation can be seen by hovering the cursor over a node.

<a name="net_R"></a>
```{r, eval=TRUE, echo=TRUE, warnings=FALSE, fig.cap=("Figure 6 Network. Node size denotes gene connectivity while edge thickness stands for coexpression similarity.") }
  
  # Static mode. For interactive mode, set "static=FALSE" 
  network(geneID="PSAC", data=exp, adj.mod=adj_mod, adj.min=0.3, con.min=0, static=TRUE)

```   

## The Integrated spatialHeatmap

<a name="shiny"></a>
All the above functionality is also combined into a web-browser based [Shiny app](https://shiny.rstudio.com/), which takes advantage of the computational power of R and interactivity of the web. This app can run locally by the function `spatial.hm.all` [@shiny] or [online](https://tgirke.shinyapps.io/spatialHeatmap/) on the Shiny server.

```{r, eval=FALSE, echo=TRUE, warnings=FALSE}

  # Lauch the Shiny app.
  spatial.hm.all()

```   

<iframe width="1100" height="2000" src="https://tgirke.shinyapps.io/spatialHeatmap/" frameborder="0" style="overflow-y:hidden; overflow-x:scroll;"></iframe>


<br/>

```{r session, eval=TRUE, echo=TRUE}

# Session informaion.
sessionInfo()

```

# Reference






















